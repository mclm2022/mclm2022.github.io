{
  "hash": "3603030854a2ed234317ed847bc38b83",
  "result": {
    "markdown": "---\ntitle: \"Tidyverse cheatsheet\"\nauthor: \"Mariana Montes\"\n---\n\n\nReference cheatsheet for some useful tidyverse functions related to dataframe manipulation.\n\n[Tidyverse](https://www.tidyverse.org/) is a collection of R packages for data wrangling and visualization (among other things). A great resource to learn how to use it is [*R for data Science*](https://r4ds.had.co.nz/).\n\n# Start\n\nSome of the packages in tidyverse are used to manipulate dataframes: those are at the center of this cheatsheet. We won't look into the particular packages but just useful functions that are likely to come in handy in different circumstances. Because of that, we'll load the full set of packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\nThe main object we will work on is a **tibble**: the tidyverse version of a **dataframe** (basically, a table). In tidy data, each row is an observation and each column, a variable. All properties of dataframes in R apply to tibbles, but they have additional benefits, such as nicer printing.\n\nWe can read tibbles from file, but in this case we'll create a dummy dataset to practice. We can use the function `tibble()` for that, indicating each column as a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble <- tibble(\n  first_column = c(1, 2, 3, 4),\n  second_column = c(\"a\", \"b\", \"a\", \"be\"),\n  third_column = c(TRUE, FALSE, FALSE, TRUE)\n)\nmy_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            2 b             FALSE       \n3            3 a             FALSE       \n4            4 be            TRUE        \n```\n:::\n\n```{.r .cell-code}\nas.data.frame(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  first_column second_column third_column\n1            1             a         TRUE\n2            2             b        FALSE\n3            3             a        FALSE\n4            4            be         TRUE\n```\n:::\n:::\n\n\n# Choose rows\n\nThe function to subset a tibble based on the content of a given column (and therefor obtain only certain rows) is `filter()`. Its first argument is the tibble, and the following arguments are the *conditions*, i.e. logical statements indicating the criteria for selection. This means we can either run `filter(my_tibble, <conditons>)` or `my_tibble %>% filter(<conditions>)`. We'll typically prefer the pipe (` %>% `).\n\n## Numeric filter\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% filter(first_column < 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            2 b             FALSE       \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% filter(first_column == 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            2 b             FALSE       \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% filter(first_column %in% c(1, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            3 a             FALSE       \n```\n:::\n:::\n\n\n## Filtering with character strings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% filter(second_column == \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            3 a             FALSE       \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% filter(startsWith(second_column, \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            2 b             FALSE       \n2            4 be            TRUE        \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% filter(second_column %in% c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            2 b             FALSE       \n3            3 a             FALSE       \n```\n:::\n:::\n\n\n## Filtering with boolean columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% filter(third_column)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            4 be            TRUE        \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% filter(!third_column)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            2 b             FALSE       \n2            3 a             FALSE       \n```\n:::\n:::\n\n\n## Combinations\n\nThe comma and `&` combine the filters, whereas `|` returns rows that are TRUE for at least one of the conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% filter(first_column > 2, second_column == \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            3 a             FALSE       \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% filter(third_column | startsWith(second_column, \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            2 b             FALSE       \n3            4 be            TRUE        \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% filter(first_column > 1 & second_column != \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            2 b             FALSE       \n2            4 be            TRUE        \n```\n:::\n:::\n\n\n## By number\n\nThe `slice_` functions let you select rows based on position.\n\n# Choose and rename columns\n\nColumns can be renamed with `select()` or `rename()`. `select()` returns a tibble that only has the requested columns, whereas `rename()` doesn't remove other columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% rename(numbers = first_column)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  numbers second_column third_column\n    <dbl> <chr>         <lgl>       \n1       1 a             TRUE        \n2       2 b             FALSE       \n3       3 a             FALSE       \n4       4 be            TRUE        \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% select(numbers = first_column, second_column)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  numbers second_column\n    <dbl> <chr>        \n1       1 a            \n2       2 b            \n3       3 a            \n4       4 be           \n```\n:::\n:::\n\n\n`select()` works with a bunch of [selection functions](https://tidyselect.r-lib.org/reference/language.html) that can save up a lot of typing. Some of the most frequent are:\n\n- `starts_with()` to select all columns that start with some pattern, e.g. `select(my_tibble, starts_with(\"first\"))` to select columns that start with \"first\".\n\n- `ends_with()` to select all columns that end in some pattern, e.g. `select(my_tibble, ends_with(\"column\"))` to select all current columns.\n\n- `contains()` to select all columns that contain a certain pattern somewhere in the name.\n\n- `where(<condition_function>)` to match all columns of a certain type, e.g. `select(my_tibble, where(is.numeric))` to select numeric columns (here \"first_column\"); `select(my_tibble, where(is.character))` to select character columns (here \"second_column\")...\n\n- `everything()` to select all columns. This is useful for example to **reorder the columns**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% \n  select(second_column, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  second_column first_column third_column\n  <chr>                <dbl> <lgl>       \n1 a                        1 TRUE        \n2 b                        2 FALSE       \n3 a                        3 FALSE       \n4 be                       4 TRUE        \n```\n:::\n:::\n\n\n# Modify data (per column)\n\nThe main function to modify data in a tibble is `mutate()`. Its first argument is a tibble, and the rest are columns with their definitions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% \n  mutate(first_column = first_column + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            2 a             TRUE        \n2            3 b             FALSE       \n3            4 a             FALSE       \n4            5 be            TRUE        \n```\n:::\n:::\n\n\nIf the column doesn't exist, it will be added.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% \n  mutate(upper_case = toupper(second_column))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  first_column second_column third_column upper_case\n         <dbl> <chr>         <lgl>        <chr>     \n1            1 a             TRUE         A         \n2            2 b             FALSE        B         \n3            3 a             FALSE        A         \n4            4 be            TRUE         BE        \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% \n  mutate(\n    multiplied = first_column * 5,\n    upper_case = toupper(second_column),\n    lett_num = paste0(upper_case, multiplied)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  first_column second_column third_column multiplied upper_case lett_num\n         <dbl> <chr>         <lgl>             <dbl> <chr>      <chr>   \n1            1 a             TRUE                  5 A          A5      \n2            2 b             FALSE                10 B          B10     \n3            3 a             FALSE                15 A          A15     \n4            4 be            TRUE                 20 BE         BE20    \n```\n:::\n:::\n\n\n# Sort\n\nThe function to sort a tibble based on the values on a column is `arrange()`. Inside of it, `desc()` allows you to sort in descending order (otherwise it will be ascending).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% arrange(desc(first_column))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            4 be            TRUE        \n2            3 a             FALSE       \n3            2 b             FALSE       \n4            1 a             TRUE        \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% arrange(second_column)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            1 a             TRUE        \n2            3 a             FALSE       \n3            2 b             FALSE       \n4            4 be            TRUE        \n```\n:::\n\n```{.r .cell-code}\nmy_tibble %>% arrange(third_column, desc(first_column))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  first_column second_column third_column\n         <dbl> <chr>         <lgl>       \n1            3 a             FALSE       \n2            2 b             FALSE       \n3            4 be            TRUE        \n4            1 a             TRUE        \n```\n:::\n:::\n\n\n# Count data\n\nThe function `count()` takes a tibble and one or more columns and returns another tibble with the same columns and their frequencies.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble %>% \n  count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1     4\n```\n:::\n:::\n\n\n\n# Make longer or wider\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}