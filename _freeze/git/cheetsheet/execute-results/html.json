{
  "hash": "4c8327bc8dd6f3e17f547d9fb502febe",
  "result": {
    "markdown": "---\ntitle: \"Git Cheetsheet\"\nauthor: \"Mariana Montes\"\nnumber-sections: true\ntoc: true\n---\n\n\nReference cheatsheet for using Git(Hub) with the course project.\n\n::: callout-caution\nThis cheatsheet assumes you already have a url for a remote repository in the `mclm2022` organization.\n\nIn other projects, you could use the url of another remote repository.\n:::\n\n# Set-up from scratch\n\n## Create an R project that is also a git repository.\n\n::: {.panel-tabset}\n  \n### Check in the box in the dialog\n\n![Initialize project](images/createProj3.png)\n\n### Use `usethis::use_git()`\n\nIf you created an R project that is not a Git repository, you can still turn it into one with `usethis::use_git()`. When an R project is also a Git repository, you will see a \"Git\" tab.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"usethis\") # if not installed\nusethis::use_git()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nâœ” Setting active project to 'C:/Users/u0118974/repos/github/mclm2022/methods-\nin-corpus-linguistics'\n```\n:::\n:::\n\n\n:::\n\n## Stage and commit\n\nA freshly created R project + git repository has two files: the \"{project-name}.Rproj\" file that indicates that it's an R project, and the \".gitignore\" file that tells Git which files not to track.\n\nBy setting up a git repository in an R project folder, \".gitignore\" is automatically populated with types of files that should be ignored:\n\n```default\n# .gitignore\n.Rproj.user\n.Rhistory\n.RData\n.Ruserdata\n```\n\nIn order to start up with git, you need to commit the files. Before committing, you need to stage the files you wish to commit. In other words, *staging* states which files you want to keep track of, and *committing* takes a snapshot of their current state.\n\n```bash\ngit add .\ngit commit -m \"first commit\"\n```\nWe stage with `git add`; `git add .` stages all files. Eventually you might want to only stage some of them, e.g. specific folders or files; in that case you type `git add my-file.txt` or `git add some-folder`.\n\nWith `git commit` we take a snapshot of all the staged files; `-m` indicates that the following text (in quotation marks) is the commit message. This message should be a short description of the change you're taking a snapshot of.\n\n## Connect to the remote\n\nThe next step after committing changes, if you want online backup or to submit something, is to `push`. This uploads the current commits to the remote repository, i.e. the url you received. However, first we have to tell git what that url is. Suppose that your url is https://github.com/mclm2022/montes.git (It will not be *montes*), then you write the following:\n\n```bash\ngit remote add origin https://github.com/mclm/montes.git\n```\n\nThis has set the url as a remote destination called `origin`. You could also add a different remote, e.g. a repository in your private account, with a different name.\n\n## Push changes\n\nFinally we can push the changes. Normally, `git push` will suffice. This first time, we indicate that the default remote location is `origin` and that we push the `main` branch, creating a `main` branch in the remote if it doesn't exist.\n\nIf your main branch is not called `main` (but maybe `master`), we first rename it (with the first line below).\n\n```bash\ngit branch -M main\ngit push -u origin main\n```\n\n::: callout-important\n### Errors in pushing\nIf you did not commit changes yet, there is nothing to push! You will get an error. Make sure you have committed something!\n:::\n\nIf you have never done something like this in R Studio, you will also be asked to identify yourself and/or log in to GitHub. Just follow the instructions on the Terminal :)\n\n# Daily workflow\n\nFor the purposes of this cheetsheet we'll assume that **all the changes happen in your local computer**. That means that your local repository will be always more up-to-date than the remote, and that there will be nothing in the remote that was not tracked in the local version.\n\nBefore/after each step, it can be useful to run `git status`, which will let you know:\n\n- In which branch you are working.\n\n- Which files, if anything are yet to be staged. (=you have to run `git add`)\n\n- Which files, if any, have been staged and are waiting to be committed. (=you have to run `git commit`)\n\n- How many commits you have that have not been pushed to the remote yet. (=you'll have to run `git push`)\n\n## Work on your local version.\n\nWrite code, write your Quarto file, whatever you want.\n\n## Stage the changes you will want to commit.\n\nHere you can select which files you want to keep and discard changes you're not interested in! You're just letting git know what it will have to track.\n\nThe handiest version is with the period/dot, which stages all files that have not been staged yet.\n\n```bash\ngit add .\n```\n\nAlternatively, you can specify a file or folder to stage, if there are files you don't want to track yet. For example, you may have changes in both your code (let's say, an \"R\" folder) and your Quarto file but you want to link them to different commit messages.\n\n```bash\ngit add R\ngit commit -m \"Updated code\"\ngit add report.qmd\ngit commit -m \"fix typos in Quarto document\"\n```\n## Commit\n\nCommitting equals to taking a snapshot of the state of your project. You can do this several times a day if you have different steps or important changes.\n\nIf you just run `git commit`, you will be taken to an editor to introduce a message. You can avoid this by adding the `-m` flag followed by an informative message.\n\n```bash\ngit commit -m \"This is a commit message\"\n```\n\nUp to committing, this is simply working locally, with Git.\n\n## Push\n\nThe command to upload your changes to the remote repository, e.g. the GitHub repository, is `git push`.\n\n```bash\ngit push\n```\n\nIf there is any incompatibility with the remote repository, you will get a warning.\n\n::: callout-note\nIf we get to the point that I give feedback by modifying your project and pushing my notes to the local repository, you will have to retrieve the changes with `git pull`. You should do that **before** you stage or commit anything else, or it will be troublesome.\n:::\n\n# Work with branches\n\nIf you want to work on a separate branch, important commands are `git checkout` and `git commit`. A branch doesn't really exist until you have commited something to it!\n\nSo, first, make sure you commited something in your `main` branch.\n\n## Create a new branch\n\nThe command to create a new branch is `git branch`.\n\n```bash\ngit branch new-branch\n```\n\nThis only sets up its creation, but does not move you to the branch.\n\n## Switch to a branch\n\nYou can move from one branch to the other with `git checkout <branch>`:\n\n```bash\ngit checkout new-branch\n```\n\nIf you're using Git Bash, you should see the name of your branch in parenthesis after the name of your directory in the Terminal.\nThe output would be something like this:\n\n```console\nuser@machine project-directory (main)\n$ git checkout new-branch\nuser@machine project-directory (new-branch)\n$\n```\n\nYou can also switch to a non-existent branch and create it simultaneously with the `-b` flag:\n\n```bash\ngit checkout -b new-branch\n```\n\n## Make changes and commit\n\nIn order for this branch to have any substance at all, you need to commit something. The example in class was to copy a folder with a corpus and to add the name of the corpus in the \".gitignore\" file. This way, the \".gitignore\" has changed and it has to be staged and committed.\n\nIf you want a more drastic change, you could create a file, such a script or a Quarto document. Once you have added and committed it, it exists in the `new-branch` branch but not in `main`.\n\n```bash\ngit add .\ngit commit -m \"start new branch\"\n```\n\nBy running `git checkout main` you will switch to the `main` branch and see that the new file is not there. You would also see that \".gitignore\" is not ignoring the corpus folder.\n\n::: {.panel-tabset}\n  \n### Push to remote\n\nIf you want to send the changes to a `new-branch` branch in the remote location (because you like the online-backup option), you can also push them. As before, the first time you will have to run:\n\n```bash\ngit push -u origin new-branch\n```\n\nAnd the rest of the times:\n\n```bash\ngit push\n```\n\nIf you do just `git push` from the beginning, it will throw you an error and give you the appropriate instructions.\n\n::: callout-important\nI will not look at things you push to branches other than `main`!\n\nIf you want to *submit* something, push the changes to the remote `main`.\n\nIf you want to keep it to yourself, push it to another branch!\n:::\n\n### Merge branches\n\nOnce you are done with a branch you can merge it with another... which doesn't mean you delete it. It just means that the current state of the new branch is brought to the previous branch. For example, if you want to bring all you have in `new-branch` to the `main` branch, you run `git checkout` followed by `git merge`. Optionally, you can delete the other branch with `git branch -d new-branch`... but it's not necessary.\n\n```bash\ngit checkout main\ngit merge new-branch\n```\n\nOr alternatively\n\n```bash\ngit merge main new-branch\n```\n\n### Move between branches\n\nIf you just want to move part of the work in one branch to the other, instead of merging them fully, you can use `git checkout <branch> <file>`, e.g.\n\n```bash\ngit checkout main\ngit checkout new-branch R\n```\n:::\n",
    "supporting": [
      "cheetsheet_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}