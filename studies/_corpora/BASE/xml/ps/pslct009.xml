<?xml version="1.0"?>
<!DOCTYPE TEI.2 SYSTEM "base.dtd">
<TEI.2><teiHeader>	
<fileDesc>
<titleStmt>
<title>unknown</title></titleStmt>
<publicationStmt><distributor>BASE and Oxford Text Archive</distributor>
<idno>pslct009</idno>	
<availability><p>The British Academic Spoken English (BASE) corpus was developed at the
Universities of Warwick and Reading, under the directorship of Hilary Nesi
(Centre for English Language Teacher Education, Warwick) and Paul Thompson
(Department of Applied Linguistics, Reading), with funding from BALEAP,
EURALEX, the British Academy and the Arts and Humanities Research Board. The
original recordings are held at the Universities of Warwick and Reading, and
at the Oxford Text Archive and may be consulted by bona fide researchers
upon written application to any of the holding bodies.
The BASE corpus is freely available to researchers who agree to the
following conditions:</p>
<p>1. The recordings and transcriptions should not be modified in any
way</p>
<p>2. The recordings and transcriptions should be used for research purposes
only; they should not be reproduced in teaching materials</p>
<p>3. The recordings and transcriptions should not be reproduced in full for
a wider audience/readership, although researchers are free to quote short
passages of text (up to 200 running words from any given speech event)</p>
<p>4. The corpus developers should be informed of all presentations or
publications arising from analysis of the corpus</p><p>
Researchers should acknowledge their use of the corpus using the following
form of words:
The recordings and transcriptions used in this study come from the British
Academic Spoken English (BASE) corpus, which was developed at the
Universities of Warwick and Reading under the directorship of Hilary Nesi
(Warwick) and Paul Thompson (Reading). Corpus development was assisted by
funding from the Universities of Warwick and Reading, BALEAP, EURALEX, the
British Academy and the Arts and Humanities Research Board. </p></availability>
</publicationStmt>
<sourceDesc>
<recordingStmt>
<recording dur="00:38:02" n="3906">
<date>01/02/2001</date><equipment><p>video</p></equipment>
<respStmt><name>BASE team</name>
</respStmt></recording></recordingStmt></sourceDesc></fileDesc>
<profileDesc>
<langUsage><language id="en">English</language>
</langUsage>
<particDesc>
<person id="nm0716" role="main speaker" n="n" sex="m"><p>nm0716, main speaker, non-student, male</p></person>
<person id="sm0717" role="participant" n="s" sex="m"><p>sm0717, participant, student, male</p></person>
<personGrp id="ss" role="audience" size="l"><p>ss, audience, large group </p></personGrp>
<personGrp id="sl" role="all" size="l"><p>sl, all, large group</p></personGrp>
<personGrp role="speakers" size="4"><p>number of speakers: 4</p></personGrp>
</particDesc>
<textClass>
<keywords>
<list>
<item n="speechevent">Lecture</item>
<item n="acaddept">Computer Science</item>
<item n="acaddiv">ps</item>
<item n="partlevel">UG1</item>
<item n="module">Introduction to systems</item>
</list></keywords>
</textClass> 
</profileDesc></teiHeader><text><body>
<u who="nm0716"> looks as though i'm trapped here so i'll # <pause dur="0.2"/> i'll leave the door open <pause dur="0.5"/><vocal desc="laugh" iterated="n"/><pause dur="0.7"/> # <pause dur="2.2"/> the last two lectures have been introducing <pause dur="1.5"/> # <pause dur="0.6"/> basically <pause dur="0.4"/> the model of the process of the memory <pause dur="0.4"/> and some simple addressing modes <pause dur="0.3"/> and <pause dur="0.4"/> we're looking at one particular instruction <pause dur="0.2"/> to see how <pause dur="0.4"/> # <pause dur="1.1"/> we <pause dur="0.5"/> # place or find operands <pause dur="0.2"/> either in registers or in the memory <pause dur="0.8"/> what i'm going to do now is to <pause dur="0.5"/> # <pause dur="0.2"/> look at <pause dur="0.2"/> writing programs in assembler <pause dur="1.6"/> and # <pause dur="1.0"/> an assembler is is a program translation system just like <pause dur="0.2"/> # a compiler although <pause dur="0.2"/> very much <pause dur="0.3"/> more simple-minded <pause dur="1.1"/> so <pause dur="0.6"/> we start off with a <pause dur="1.0"/> # <pause dur="0.4"/> source program file you created with an editor or whatever <pause dur="0.6"/> # <pause dur="0.6"/> you invoke <pause dur="0.6"/> the assembler program to assemble it for you <pause dur="0.3"/> and this will produce <pause dur="0.2"/> typically two files a binary program <pause dur="0.4"/> and a listing file <pause dur="1.4"/> now <pause dur="0.3"/> the binary file <pause dur="0.5"/> is the one that you load into the machine and actually execute in other words <pause dur="0.2"/> it's producing an executable program for you <pause dur="2.2"/> okay now <pause dur="1.7"/> the <pause dur="0.3"/> machines that we'll use i i'll be arranging some 
practicals a bit later on in the term <pause dur="0.7"/> # <pause dur="0.5"/> and <pause dur="1.4"/> we'll be using <pause dur="0.3"/> the # <pause dur="0.4"/> P-Cs <pause dur="0.4"/> okay <pause dur="0.4"/> now the P-Cs of course have <pause dur="0.2"/> an Intel architecture <pause dur="1.2"/> but <pause dur="0.7"/> i'm teaching you <pause dur="0.2"/> sixty-eight-thousand architecture <pause dur="0.3"/> well <pause dur="0.3"/> the <pause dur="0.4"/> # way round that of course is to <pause dur="0.2"/> write a program or a a a package <pause dur="0.3"/> which <pause dur="0.2"/> will <pause dur="1.4"/> # assemble <pause dur="0.2"/> and <pause dur="0.2"/> emulate the sixty-eight-thousand machine <pause dur="0.3"/> and that's what <pause dur="0.4"/> # we will use <pause dur="1.4"/> it has a certain few little peculiarities but <pause dur="0.6"/> it's sufficient for the purposes <pause dur="0.4"/> of <pause dur="0.6"/> # this term <pause dur="2.8"/> now <pause dur="0.8"/> you've been <pause dur="0.4"/> used to writing <pause dur="0.3"/> # <pause dur="1.2"/> programs in # object-<pause dur="0.3"/>oriented Pascal <pause dur="1.6"/> # <pause dur="0.4"/> and they are free format that is <pause dur="0.4"/> you can lay it out any way you like <pause dur="0.2"/> although <pause dur="0.5"/> i'm sure <pause dur="0.2"/> you've been <pause dur="0.3"/> told to indent <pause dur="0.7"/> # <pause dur="0.5"/> statements when they're in a loop and <pause dur="0.5"/> and so on <pause dur="0.2"/> all right so that you can read it easily <pause dur="0.7"/> but <pause dur="0.2"/> in principle <pause dur="0.3"/> you could <pause dur="0.8"/> start <pause dur="1.0"/> at the top you know at the top of the file and just write it as <pause dur="0.3"/> a single <pause dur="1.1"/> # <pause dur="0.2"/> complete <pause dur="0.7"/> statement because <pause dur="0.4"/> the or set of statements because in fact <pause dur="0.4"/> # a Pascal program <pause dur="0.3"/> is in fact <pause dur="0.3"/> # <pause dur="0.3"/> one <pause dur="0.7"/> # <pause dur="2.4"/> single <pause dur="0.4"/> # <pause dur="2.1"/> # entity as far as the 
compiler concerned it will take everything up to a full stop <pause dur="1.0"/> the <pause dur="1.5"/><kinesic desc="changes transparency" iterated="y" dur="6"/> assembler is different because <pause dur="2.3"/> it's one statement per line <pause dur="1.4"/> okay <pause dur="1.5"/> and the statement <pause dur="0.2"/> will have <pause dur="0.7"/> fields <pause dur="0.7"/> okay so immediately <pause dur="0.2"/> position within the <pause dur="1.2"/> the line is important <pause dur="0.7"/> all right <pause dur="0.2"/> whereas before in Pascal it doesn't <pause dur="0.8"/> matter <pause dur="1.8"/> as far <pause dur="0.4"/> here <pause dur="0.6"/> with assembler it does <pause dur="0.4"/> and a field <pause dur="0.7"/> obviously has to have a terminator <pause dur="0.3"/> you've got <pause dur="0.7"/> and # <pause dur="0.3"/> here <pause dur="0.4"/> this can be either a space typically a field will # have a <pause dur="0.3"/> one or more spaces as a terminator <pause dur="0.7"/> or <pause dur="0.8"/> end of line <pause dur="1.5"/> so <pause dur="2.0"/> there are three sorts of statement we're going to to use <pause dur="0.2"/> in in the assembler that you're going to <pause dur="0.3"/> employ <pause dur="0.4"/> the first one <pause dur="0.5"/> is an instruction statement <pause dur="0.7"/> which starts off <pause dur="0.2"/> with a null field <pause dur="1.1"/> okay <pause dur="0.8"/> and then we'll have <pause dur="1.0"/> three fields <pause dur="0.7"/> a mnemonic field <pause dur="0.3"/> an address field <pause dur="1.7"/> and <pause dur="0.3"/> a comment <pause dur="0.4"/> now the comment itself <pause dur="0.3"/> is <pause dur="0.4"/> # begins with a <pause dur="0.2"/> semicolon but it's optional you can either put a comment in or not <pause dur="0.8"/> now what i'll be doing is <pause dur="0.4"/> using the comment <pause dur="0.3"/> # as a way of <pause dur="0.5"/> # <pause dur="0.3"/> writing <pause dur="0.2"/> the <pause dur="0.2"/> informal Pascal that 
i'm going to use to <pause dur="0.4"/> # <pause dur="0.6"/> generate the assembler <pause dur="2.8"/> you can have a label statement <pause dur="0.2"/> which is <trunc>s</trunc> <pause dur="0.3"/> simply a name <pause dur="0.2"/> followed by a code <pause dur="0.4"/> and you can have up to fifteen letters it's a very simple <pause dur="0.3"/> assembler as i said normally <pause dur="0.5"/> one would be able to be a bit bit bit more flexible than that <pause dur="1.8"/> and directives <pause dur="0.9"/> okay <pause dur="0.6"/> these are <pause dur="0.3"/> an instruction to <pause dur="0.2"/> the assembler program itself <pause dur="0.8"/> okay to declare variables or <pause dur="0.2"/> symbolic <pause dur="0.4"/> constants <pause dur="2.4"/> so we're going to <pause dur="0.9"/> # <pause dur="0.3"/> construct <pause dur="0.5"/> programs <pause dur="0.7"/> # from <pause dur="0.7"/> sets of instructions <pause dur="0.6"/> we'll need labels because <pause dur="0.5"/> # we'll have to have explicit jumps or branches and we'll need labels to do that <pause dur="0.5"/> and we'll also have to <pause dur="0.2"/> declare <pause dur="0.3"/> variables in a simplistic way <pause dur="2.1"/> so what is a <pause dur="0.8"/><kinesic desc="changes transparency" iterated="y" dur="6"/> let's just have a look at one just to sort of see <pause dur="0.5"/> the shape we won't necessarily understand every statement in it but <pause dur="0.3"/> you can see <pause dur="0.2"/> the three types here <pause dur="2.1"/> okay <pause dur="0.5"/> but first of all <pause dur="2.1"/> that's the <pause dur="0.2"/> comment and # and it's a very simple program it says <pause dur="0.5"/> if A is greater than equal to B <pause dur="0.2"/> R becomes A else R becomes B <pause dur="1.3"/> and there's one or two other 
bits and pieces <pause dur="0.4"/> okay so it's a very simple little program <pause dur="1.3"/> here <pause dur="1.4"/> the label field <pause dur="0.3"/> the mnemonic field the address field <pause dur="0.6"/> although you don't have to line them up as long as you've got a terminator there <pause dur="0.2"/> it does make some sense to line them up so you can read it <pause dur="3.3"/> okay so <pause dur="1.1"/> here <pause dur="1.7"/> from the move <pause dur="0.7"/> down J-S-R these are <pause dur="0.3"/> instruction statements <pause dur="0.4"/> mm <pause dur="0.2"/> so <pause dur="0.2"/> there's a null field here <pause dur="0.9"/> mnemonic <pause dur="1.1"/> and the address <pause dur="0.2"/> A-comma-D-nought some you get we're <pause dur="0.2"/> fairly familiar with already <pause dur="3.7"/> down here <pause dur="0.8"/> that's how we declare <pause dur="0.5"/> variables <pause dur="0.6"/> okay so there's A-colon <pause dur="1.2"/> it's got word <pause dur="0.2"/> got to say how long it is <pause dur="0.5"/> and there's an integer value <pause dur="2.1"/> the # <pause dur="0.7"/> the integer values <pause dur="0.5"/> are <pause dur="0.4"/> # <pause dur="0.2"/> when the assembler generates the <pause dur="0.5"/> variables <pause dur="0.2"/> it well space for the variables it initializes A B and C to the values that we've put here <pause dur="3.9"/> here is a <pause dur="0.3"/> directive which is to to <trunc>d</trunc> <pause dur="0.2"/> # <pause dur="0.6"/> declare constants <pause dur="1.1"/> and this <pause dur="0.6"/> is in fact how we're going to interact with <pause dur="0.3"/> in a very simple way with the <pause dur="0.3"/> emulator <pause dur="0.4"/> okay <pause dur="0.3"/> but the emulator's going to run this program <pause dur="0.5"/> but <pause dur="0.2"/> we've actually got to 
say <pause dur="0.3"/> when to stop <pause dur="0.7"/> so <pause dur="1.0"/> you need to <pause dur="0.2"/> have <pause dur="0.4"/> an explicit address of where to jump to <pause dur="0.3"/> and here is <pause dur="0.4"/> a jump to the subroutine or procedure <pause dur="0.4"/> which <pause dur="0.2"/> will <pause dur="0.2"/> stop the program <pause dur="0.4"/> and <pause dur="0.5"/> # <pause dur="1.8"/> allow you to inspect what's gone on <pause dur="2.5"/> so <pause dur="2.0"/> there will always be <pause dur="0.5"/> one of those in every program that you write <pause dur="0.6"/> there'll be a few <pause dur="0.3"/> instructions like this <pause dur="0.8"/> and then there'll be some <pause dur="0.3"/> simple variables <pause dur="0.6"/> okay that's what we'll be doing <pause dur="0.6"/> for the time being <pause dur="16.8"/><kinesic desc="changes transparency" iterated="y" dur="21"/> just to sort of <pause dur="2.6"/> look at <pause dur="2.2"/> instructions a bit more <pause dur="0.8"/> so <pause dur="0.9"/> the mnemonic field contains the symbolic reputation of the operation you want <pause dur="0.4"/> now you've <pause dur="0.4"/> had <pause dur="1.0"/> # <pause dur="2.3"/> a new set of notes given out <pause dur="1.0"/> at the back <pause dur="1.2"/> if you'd like to have a look <pause dur="3.3"/> okay <pause dur="1.6"/> there's all <pause dur="1.2"/> the instructions <pause dur="2.0"/> okay <pause dur="3.0"/> <trunc>th</trunc> those are all the mnemonics <pause dur="2.3"/><vocal desc="cough" iterated="n"/><pause dur="1.7"/> now <pause dur="1.0"/> # <pause dur="0.6"/> the way <pause dur="0.3"/> it's it's expressed is a series of columns of course <pause dur="0.3"/> there is a a name which is <pause dur="0.3"/> # like add or <pause dur="0.3"/> # <pause dur="0.8"/> # <pause dur="0.2"/> branch always and so on <pause dur="1.1"/> there's the assemble syntax for all of the <pause dur="0.5"/> instructions that you <pause dur="0.3"/> # <pause dur="1.4"/> are going to use for <trunc>n</trunc> or you 
could use you you won't necessarily have to use all of these but i i've <pause dur="0.2"/> done a fairly complete set just to <pause dur="0.5"/> # <pause dur="0.7"/> # <pause dur="1.2"/> for those who are interested <pause dur="0.7"/> and then <pause dur="0.9"/> using the notation i developed in the first two lectures <pause dur="1.0"/> there is the operations <pause dur="0.6"/> all right <pause dur="0.3"/> that <pause dur="1.6"/> # <pause dur="0.4"/> occur <pause dur="0.4"/> that that the the the # when you execute the instruction <pause dur="0.7"/> but finally <pause dur="0.5"/> the illegal <pause dur="0.8"/> effective addresses <pause dur="0.3"/> if there are any <pause dur="2.4"/> okay <pause dur="3.4"/> it would be a good idea if you <pause dur="0.2"/> <trunc>po</trunc> possibly detach that from the notes 'cause you'll need that for the <pause dur="0.3"/> practicals <pause dur="9.1"/> okay so <pause dur="0.7"/> the mnemonic field it's one of the you <pause dur="0.2"/> select the operation you want at any particular point <pause dur="0.3"/> and <pause dur="0.4"/> put it in the mnemonic field <pause dur="0.5"/> the address field <pause dur="0.3"/> it's the operand addresses <pause dur="0.3"/> okay <pause dur="0.2"/> we've we <pause dur="0.4"/> and it can be either in symbolic form we can use a name <pause dur="1.3"/> or it's constants <pause dur="0.3"/> right the that's # <pause dur="1.9"/> so <pause dur="1.0"/> what would symbolic names <pause dur="0.8"/> they can be <pause dur="0.2"/> memory variables <pause dur="0.7"/> okay <pause dur="1.0"/> A B <pause dur="0.2"/> C and so on <pause dur="1.2"/> they can be <pause dur="0.4"/> # <pause dur="0.2"/> predefined <pause dur="0.7"/> register names <pause dur="0.3"/> D-nought D-one and so on <pause dur="0.7"/> and <pause dur="0.2"/> label names <pause dur="0.7"/> which we saw in the example 
program <pause dur="3.1"/> decimal constants <pause dur="0.6"/> oll constants can be either <pause dur="0.4"/> # decimal <pause dur="0.3"/> or <pause dur="0.2"/> hexadecimal <pause dur="0.4"/> or in fact <pause dur="0.4"/> character where we we <pause dur="1.1"/> enclose our <pause dur="0.3"/> character within <pause dur="0.5"/> # <pause dur="0.6"/> quotes <pause dur="8.3"/> 
so the language isn't very extensive <pause dur="0.3"/> right there's not <pause dur="1.1"/><kinesic desc="changes transparency" iterated="y" dur="12"/> there's not many rules <pause dur="9.7"/> so <pause dur="3.4"/> a symbolic constant <pause dur="0.3"/> symbol name <pause dur="0.5"/> equals a constant value <pause dur="3.6"/> the symbol name is the same as a <pause dur="0.4"/> # a label but # it doesn't have the <pause dur="0.3"/> the the <pause dur="0.2"/> colon after it <pause dur="0.7"/> and a constant value in this case is <pause dur="0.5"/> restricted to <trunc>pos</trunc> <pause dur="0.3"/> positive decimal or hexadecimal so there are sort of funny <pause dur="0.5"/> little inconsistencies here i i <pause dur="0.8"/> # <pause dur="0.6"/> if the <pause dur="0.2"/> it # <pause dur="0.2"/> i did write an assembler once and there's no <pause dur="0.4"/> particular reason why it should be so but that's what it is with the assembler we've got <pause dur="1.1"/> # <pause dur="1.3"/> what the assembler will do just as it does in a in in your Pascal program <pause dur="0.3"/> it will <pause dur="0.2"/> replace any <pause dur="0.4"/> # symbol name with that constant value <pause dur="0.5"/> okay <pause dur="1.2"/> so it it it works in in <trunc>exa</trunc> exactly the same way in Pascal of course <pause dur="0.8"/><vocal desc="sniff" iterated="n"/><pause dur="2.4"/> # <pause dur="0.6"/> one or more <pause dur="1.4"/> memory variables we can <pause dur="1.9"/> say <pause dur="0.2"/> we can add a label <pause dur="1.0"/> colon <pause dur="0.4"/> dot type <pause dur="0.2"/> 
where <pause dur="0.2"/> that's going to <pause dur="0.2"/> determine how <pause dur="0.3"/> long <pause dur="0.4"/> the # <pause dur="0.8"/> operand is or or # or the variable is <pause dur="0.3"/> and we can have a list of one or more constants there <pause dur="1.6"/> well what happens here is the <pause dur="0.2"/> assembler will reserve space at that particular point in the program <pause dur="1.7"/> okay <pause dur="0.5"/> and <pause dur="0.6"/> what it will do is associate the name <pause dur="0.9"/> with <pause dur="0.4"/> the address in memory <pause dur="0.7"/> okay so what we've got <pause dur="0.4"/> # <pause dur="2.8"/> and that's the address of the most significant byte <pause dur="13.4"/><kinesic desc="changes transparency" iterated="y" dur="12"/> okay so let's so <pause dur="1.7"/> here i'm <pause dur="2.1"/> declaring <pause dur="0.6"/> a byte variable <pause dur="0.3"/> a word variable <pause dur="0.2"/> a long word variable <pause dur="1.8"/> and if those were three successive statements in the <pause dur="0.3"/> # <pause dur="0.8"/> # <pause dur="0.7"/> in the # <pause dur="0.6"/> in the assembler then <pause dur="0.9"/> what would happen <pause dur="2.8"/> in memory <pause dur="0.2"/> is essentially you'd have <pause dur="0.6"/> # <pause dur="6.2"/> byte int <pause dur="4.0"/> then there'd be a word int <pause dur="4.3"/> so that would be <pause dur="0.6"/> two bytes <pause dur="2.0"/> # and a long word int <pause dur="10.8"/> four bytes <pause dur="3.1"/> and these would be initialized for the values you've got here <pause dur="0.7"/> if we're thinking about addresses this would be <pause dur="0.3"/> some address and that would be A <pause dur="0.9"/> # <pause dur="1.0"/> A-plus-one or A-<pause dur="0.2"/>plus-<pause dur="0.9"/>#-three <pause dur="0.5"/> right so it would associate <pause dur="1.5"/> the name <pause dur="0.6"/> for the particular address <pause dur="1.9"/> one <pause dur="0.9"/> # <pause dur="1.2"/> issue <pause dur="0.2"/> with # <pause dur="0.6"/> # <pause dur="0.4"/> 
the assembler is that or or the machine is <pause dur="0.3"/> that these have to be on word boundaries so you have to do something about that <pause dur="0.2"/> but <pause dur="0.3"/> what i want you to to <pause dur="0.2"/> to go away with is the fact that <pause dur="0.4"/> when you write the <pause dur="0.2"/> a <pause dur="3.6"/> the word byte int or word int in in a in a an instruction <pause dur="0.6"/> okay what <pause dur="0.2"/> happens is <pause dur="0.4"/> the assembler will replace it with the address <pause dur="0.3"/> that it's allocated the variable in <pause dur="5.0"/> now you can <pause dur="2.3"/> declare lists of bytes and words and long words and there's <trunc>li</trunc> <pause dur="0.6"/> # <pause dur="0.6"/> a word list and it will <pause dur="0.6"/> reserve three words and initialize them to those <pause dur="0.4"/> values <pause dur="0.6"/> okay <pause dur="4.3"/> so <pause dur="2.5"/> that's how we <pause dur="0.7"/> declare variables <pause dur="0.8"/> and we will normally declare them at the <trunc>bo</trunc> bottom of the program <pause dur="6.3"/><kinesic desc="changes transparency" iterated="y" dur="40"/> we'll only need <pause dur="0.4"/> for <pause dur="0.5"/> as i say the the examples and and from now on we'll only need to declare <pause dur="0.4"/> # <pause dur="0.2"/> simple <pause dur="0.4"/> # integer variables and # and and we'll just take that on <pause dur="0.5"/> for <pause dur="0.4"/> # through the next few lectures so <pause dur="0.5"/> we're only interested in word <pause dur="0.2"/> integers <pause dur="0.2"/> at this point <pause dur="8.0"/> now <pause dur="2.1"/> what we're going to do <pause dur="0.4"/> is to generate <pause dur="0.9"/> all right take <pause dur="3.9"/> Pascal statements <pause dur="0.2"/> 
okay which <pause dur="0.4"/> # <pause dur="0.8"/> and <pause dur="0.9"/> generate <pause dur="0.5"/> templates or rules <pause dur="0.9"/> for <pause dur="0.3"/> generating <pause dur="0.2"/> the assembler <pause dur="0.5"/> from them <pause dur="0.5"/> okay <pause dur="0.2"/> that's the <pause dur="0.9"/> # <pause dur="0.7"/> technique we're going to use <pause dur="0.3"/> and we're going to start <pause dur="0.3"/> with <pause dur="0.4"/> assignment <pause dur="1.0"/> now <pause dur="0.2"/> the general Pascal statement <pause dur="0.5"/> # <pause dur="0.8"/> is you assign an expression to a variable <pause dur="1.1"/> okay <pause dur="0.4"/> and <pause dur="0.2"/> to start with we'll <pause dur="0.2"/> make the simplest expression we can <pause dur="0.5"/> do is make our expression either <pause dur="0.3"/> a constant or <pause dur="0.3"/> # <pause dur="0.2"/> a variable <pause dur="2.1"/> so <pause dur="0.8"/> <trunc>i</trunc> in order to develop a template for this we've got to say what instructions <pause dur="0.2"/> will support this sort of activity <pause dur="1.4"/> well of course <pause dur="2.3"/> vary the move statement <pause dur="0.5"/> okay and and you can look it up in your <pause dur="0.2"/> list of <pause dur="0.6"/> whatever with there there's a move statement <pause dur="0.7"/> and <pause dur="0.4"/> this will move <pause dur="0.2"/> # <pause dur="0.2"/> the contents of <pause dur="0.9"/> the source operand <pause dur="0.4"/> to <pause dur="0.4"/> contents of the destination operand <pause dur="2.6"/> okay <pause dur="1.0"/> now <pause dur="3.3"/> let's take <pause dur="0.7"/> we want to do <pause dur="0.5"/> # <pause dur="1.1"/> an assignment which is just P becomes Q <pause dur="0.5"/> <unclear>is that</unclear> <pause dur="0.2"/> very simple <pause dur="0.7"/> then <pause dur="1.0"/> P and Q <pause dur="0.6"/> # <pause dur="0.3"/> our memory variables <pause dur="0.4"/> and <pause dur="0.4"/> this is <pause dur="2.2"/> fairly straightforward you just have to decide what <pause dur="0.4"/> length <pause dur="0.7"/> the wretched thing is <pause dur="0.4"/> all right <pause dur="0.7"/> 
because <pause dur="0.6"/> # you can either <pause dur="0.3"/> # be a byte a word or a long word <pause dur="0.5"/> as i say we'll mostly <pause dur="0.3"/> <trunc>conc</trunc> <pause dur="0.2"/> concentrate on that <pause dur="1.2"/> so P becomes Q <pause dur="0.4"/> but <pause dur="1.6"/> that of course is the destination <pause dur="1.7"/> and that's the source <pause dur="0.5"/> yeah <pause dur="0.8"/> you agree <pause dur="0.9"/> so <pause dur="0.2"/> you have to reverse <pause dur="0.5"/> P and Q <pause dur="0.7"/> to what the <unclear>Pascal</unclear> is <pause dur="3.1"/> yeah <pause dur="2.9"/> contents of <pause dur="0.6"/> Q <pause dur="1.7"/> # if we look at it the assembler instruction <pause dur="0.4"/> the contents of Q is assigned to <pause dur="1.1"/> contents of P <pause dur="0.5"/> but of course in our <pause dur="0.7"/> high level language we do it the other way round <pause dur="0.5"/> it's one of the <pause dur="1.0"/> qualities of <pause dur="0.2"/> of # <pause dur="1.4"/> working with a machine at this level <pause dur="0.7"/> right that that's the one thing you just that's just the that's the only <trunc>re</trunc> <pause dur="0.5"/> all right <pause dur="0.7"/> source <pause dur="0.2"/> destination just keep that <pause dur="0.3"/> quote in your head <pause dur="0.4"/> source <pause dur="0.4"/> destination <pause dur="12.3"/><kinesic desc="changes transparency" iterated="y" dur="20"/> and of course <pause dur="0.8"/> we could have some more examples of that <pause dur="5.8"/> flat screen <pause dur="1.5"/> they're all of the same <pause dur="0.7"/> type here <pause dur="1.1"/> where <pause dur="2.5"/> what i've done <pause dur="0.3"/> is to <pause dur="3.1"/> assign <pause dur="0.7"/> move <pause dur="0.9"/> # <pause dur="0.2"/> whoops i've got a dot there i don't need <pause dur="2.4"/> # <pause dur="2.2"/> first of all if i just write move without a qualifier qualifier-dot-B-dot-W-dot-L <pause dur="0.2"/> it takes a word by default so <pause dur="0.7"/> if 
i don't <pause dur="1.0"/> put anything in <pause dur="0.2"/> it's a word <pause dur="1.9"/> this is how we can move <pause dur="0.6"/> data between <pause dur="0.8"/> registers <pause dur="0.8"/> from a register to memory <pause dur="1.1"/> # <pause dur="0.4"/> and <pause dur="0.7"/> # from memory to a register <pause dur="0.4"/> which we will find we'll have to do <pause dur="0.5"/> # <pause dur="0.6"/> not infrequently <pause dur="6.9"/> and finally <pause dur="0.3"/> how do we assign the constants <pause dur="0.7"/> well <pause dur="0.8"/> you can <pause dur="1.4"/> just use the immediate form of addressing which we we introduced <pause dur="0.3"/> last time <pause dur="2.9"/> and <pause dur="1.3"/> we would move <pause dur="0.2"/> twenty-one in <pause dur="0.4"/> assign <pause dur="0.2"/> twenty-one-P <pause dur="0.2"/> and minus-thirty-four to <pause dur="0.2"/> D-four <pause dur="0.2"/> so <pause dur="0.9"/> that's one way <pause dur="0.4"/> of <pause dur="0.3"/> assigning <pause dur="0.6"/> # <pause dur="1.1"/> constants <pause dur="1.8"/> okay so we now know how to <trunc>s</trunc> assign constants and variables <pause dur="0.2"/> whichever they are <pause dur="0.3"/> and what we'll do is treat <pause dur="0.6"/> # <pause dur="1.1"/> registers as just predefined <pause dur="0.7"/> variable names <pause dur="0.2"/> okay <pause dur="1.7"/> from a <pause dur="0.4"/> symbolic <unclear>point of view</unclear> that's all they are they're just predefined <pause dur="0.5"/> variable names <pause dur="3.6"/> any questions so far <pause dur="2.5"/> okay <pause dur="7.0"/><kinesic desc="changes transparency" iterated="y" dur="16"/> now the one thing about assembler is you can always do things in other ways okay <pause dur="0.2"/> so there's always <pause dur="8.7"/> first of all <pause dur="4.1"/> i guess you do write <pause dur="0.8"/> initialize something to zero quite frequently don't you <pause dur="0.4"/> yeah <pause dur="1.2"/> well there's a hardware instruction 
to do that <pause dur="1.2"/> # <pause dur="1.0"/> and # <pause dur="0.2"/> it's called clear and you can clear <pause dur="0.3"/> registers or memory that way <pause dur="2.3"/> and so here is just <pause dur="1.2"/> <unclear>vision</unclear> clear <pause dur="1.0"/> and <pause dur="0.7"/> the Pascal form <pause dur="0.2"/> to the right <pause dur="0.9"/> okay <pause dur="10.6"/> now <pause dur="3.5"/> if a constant's less than two-hundred-and-fifty-six <pause dur="1.0"/> why two-hundred-and-fifty-six <pause dur="0.2"/> well why it's nought to two-<pause dur="1.0"/>#-five-five <pause dur="1.0"/> they use a field within the instruction which is a byte long <pause dur="3.7"/> yeah <pause dur="3.0"/> you all realize a byte can contain <pause dur="0.2"/> up to two-five-five yeah <pause dur="0.5"/> # <pause dur="2.0"/> so there's a field in the instruction <pause dur="0.7"/> and what it is is <pause dur="1.2"/> # <pause dur="1.1"/> you can use move quick <pause dur="1.4"/> for for smaller constants <pause dur="0.6"/> and what it does is to <pause dur="0.2"/> save space <trunc>i</trunc> the the <trunc>r</trunc> the instruction isn't as long <pause dur="0.8"/> as <pause dur="1.2"/> # a move with an immediate form <pause dur="1.2"/> okay <pause dur="1.1"/> you don't have any extension words in fact <pause dur="0.7"/> and <pause dur="1.3"/> this all comes about because <pause dur="0.5"/> # <pause dur="0.2"/> when <pause dur="1.2"/> the <pause dur="0.3"/> <trunc>s</trunc> <pause dur="0.8"/> sixty-eight-thousand and the Intel were all being designed <pause dur="0.5"/> it was very important to save memory i mean it's one of these cases where <pause dur="0.5"/> # <pause dur="1.7"/> the constraints <pause dur="0.8"/> of <pause dur="0.2"/> # machines <pause dur="0.3"/> at the time <pause dur="0.3"/> affected how the architecture was was put together <pause dur="0.6"/> it was very important to 
try to keep <pause dur="0.2"/> programs as small as possible <pause dur="0.5"/> also <pause dur="0.3"/> they tried to <pause dur="0.4"/> make <pause dur="0.3"/> the instructions as short in terms of machine cycles as possible 'cause they were very slow <pause dur="0.8"/> all right <pause dur="0.8"/> it was a <pause dur="0.4"/> # <pause dur="0.6"/> the # <pause dur="1.9"/> early <pause dur="0.5"/> # <pause dur="3.8"/> micros <pause dur="0.3"/> were extraordinarily slow <pause dur="0.4"/> i mean you you just <pause dur="1.1"/> well we were talking now typically <pause dur="0.5"/> # <pause dur="0.9"/> # you know a gigahertz clock we were talking about two megahertz <pause dur="1.2"/> all right <pause dur="2.5"/> 
so <pause dur="0.7"/> and memory <pause dur="0.2"/> cost an awful lot of money <pause dur="2.0"/> okay so <pause dur="0.6"/> # you wanted to <pause dur="0.8"/> have <pause dur="1.2"/> instructions as short <trunc>a</trunc> you know programs as short as you can <pause dur="0.2"/> so there were a lot of different variants of instructions and that's why there's <pause dur="0.2"/> partly why the sixty-eight-thousand looks like it does <pause dur="2.4"/> what we've done now in in the the last ten years or so <pause dur="0.3"/> is to <pause dur="0.6"/> have a completely different architectural design and <pause dur="1.3"/> where every instruction has the same length <pause dur="1.4"/> right as <pause dur="0.6"/> we'd used instruction set after it <pause dur="0.4"/> in fact <pause dur="0.4"/> we <pause dur="0.3"/> # <pause dur="0.7"/> can only do arithmetic for example <pause dur="0.2"/> using registers you can't <pause dur="0.4"/> # do arithmetic involving memory which you can with a sixty-eight-thousand <pause dur="1.4"/> 
what this means is is you can clock the <pause dur="0.7"/> processor very much faster <pause dur="1.5"/> all right and as we <trunc>m</trunc> <pause dur="0.3"/> make chips smaller and smaller <pause dur="0.7"/> so the clock rate goes up <pause dur="0.3"/> so that's really what's been happening <pause dur="1.1"/> okay <pause dur="3.2"/> so <pause dur="0.2"/> the reason for all of this <pause dur="1.0"/> is to <pause dur="0.4"/> it was to try to <pause dur="0.4"/> # <pause dur="0.5"/> minimize programs # both in terms of space and execution time <pause dur="8.2"/><kinesic desc="changes transparency" iterated="y" dur="18"/> what we'll do <pause dur="0.6"/> # <pause dur="3.4"/> next is to to <pause dur="0.4"/> just <pause dur="0.6"/> look at <pause dur="1.6"/> how do we encode <pause dur="0.6"/> <trunc>s</trunc> <pause dur="0.2"/> # expressions <pause dur="0.4"/> and assignment <pause dur="0.2"/> where they simple integer expressions <pause dur="0.2"/> so <pause dur="0.7"/> # <pause dur="12.1"/> okay <pause dur="0.4"/> now we looked <pause dur="0.2"/> add was our running example for the first two <pause dur="0.2"/> lectures <pause dur="0.9"/> okay <trunc>w</trunc> it and <pause dur="0.4"/> we could write it in a form where <pause dur="0.2"/> the <pause dur="0.4"/> # <pause dur="0.2"/> and there there's a subtract which is very similar of course <pause dur="1.8"/> and we can write down <pause dur="2.0"/> this is formally what happens that destination becomes destination so <pause dur="0.3"/> there is addition <pause dur="0.2"/> but also an assignment <pause dur="0.7"/> <trunc>th</trunc> <pause dur="0.2"/> there's as a single in # operation <pause dur="2.5"/> but just as there are two <pause dur="0.8"/> variants of add so there are two variants of <pause dur="0.5"/> subtract and we saw that we needed that if we wanted to <pause dur="0.4"/> add and subtract to <pause dur="1.0"/> memory <pause dur="4.8"/> 
and <pause dur="0.2"/> for this form <pause dur="0.2"/> there were various illegal forms of <pause dur="0.4"/> # <pause dur="0.9"/> the <pause dur="1.3"/> # effective address <pause dur="0.5"/> in the <pause dur="0.6"/> # <pause dur="2.1"/> that's all detailed on your instruction sheet <pause dur="0.5"/> # for any particular instruction <pause dur="1.8"/> now <pause dur="3.5"/> if the operands are in the right place <pause dur="2.2"/> then <pause dur="2.2"/> simple instructions <pause dur="1.4"/> can be encoded <pause dur="0.2"/> simple expressions <pause dur="0.6"/> can be encoded in one instruction <pause dur="0.4"/> yeah 'cause <pause dur="0.2"/> this looks <pause dur="1.1"/> quite useful doesn't it in terms of of how to encode a piece of Pascal <pause dur="0.2"/> so <pause dur="0.6"/> here we are <pause dur="1.3"/> this adds <pause dur="0.6"/> contents of <pause dur="1.5"/> a # memory variable to <pause dur="0.6"/> # <pause dur="2.8"/> a data register <pause dur="0.5"/> and here <pause dur="0.4"/> we're using the second form <pause dur="0.6"/> to <pause dur="0.2"/> whoops <pause dur="11.8"/> and that would subtract it <pause dur="3.4"/> but the <pause dur="2.1"/> trouble is <pause dur="2.4"/><kinesic desc="changes transparency" iterated="y" dur="4"/> that <pause dur="0.4"/> life isn't always quite as simple as that <pause dur="0.4"/> but <pause dur="0.6"/> okay well <pause dur="0.9"/> we'll just do another simple case which is just <pause dur="0.5"/> how we add constants <pause dur="0.2"/> and then we'll come back to more complicated expressions <pause dur="0.3"/> and and we'll learn <pause dur="0.8"/> a relatively simple technique which <pause dur="0.4"/> # <pause dur="0.3"/> will <pause dur="0.7"/> # <pause dur="2.4"/> to evaluating <pause dur="0.3"/> # expressions simple expressions <pause dur="2.3"/> we've already seen what's what's going on <pause dur="0.2"/> am i <pause dur="0.7"/> doing the encoding all right the <pause dur="2.4"/> source 
destination so <pause dur="0.9"/> D-six becomes D-six-plus-P <pause dur="0.3"/> yeah <pause dur="1.4"/> so i i take that and look at that <pause dur="0.9"/> generate A <pause dur="1.4"/> it's B the source is P so i write P <pause dur="0.3"/> comma <pause dur="0.4"/> destination is D-six <pause dur="0.4"/> so i write D-six <pause dur="15.3"/><kinesic desc="changes transparency" iterated="y" dur="11"/> well <pause dur="5.8"/> we often add constants I becomes I-plus-one is fairly <pause dur="0.3"/> familiar <pause dur="0.3"/> # <pause dur="0.9"/> sort of a construction in Pascal <pause dur="0.3"/> and here <pause dur="0.5"/> we obviously can use <pause dur="1.7"/> the immediate <pause dur="0.2"/> form <pause dur="0.3"/> as well <pause dur="2.2"/> just as we did with <pause dur="0.8"/> assigning the constants so here we can just add a constant to <pause dur="0.3"/> a register <pause dur="0.8"/> okay <pause dur="3.5"/> now this form <pause dur="1.6"/> obviously <pause dur="2.2"/> in general its sum becomes sum-plus-constant <pause dur="1.7"/> there are <pause dur="0.4"/> as before variants to <pause dur="0.5"/> # <pause dur="2.9"/> produce <pause dur="0.2"/> shorter or <pause dur="0.5"/> # faster <pause dur="0.5"/> # <pause dur="1.0"/> instructions <pause dur="0.9"/> and there's <pause dur="0.4"/> # an immediate <pause dur="3.7"/> which we'll do add there's <pause dur="0.4"/> here we add <pause dur="0.2"/> to memory <pause dur="0.7"/> and <pause dur="0.5"/> here <pause dur="0.5"/> add quick we can add <pause dur="0.8"/> again <pause dur="0.6"/> # <pause dur="1.8"/> add to <pause dur="0.4"/> memory there <pause dur="3.3"/> add quick <pause dur="0.3"/> is in fact very small 'cause we only got three bit field here <pause dur="0.5"/> you can only do between one and eight but if you think about it <pause dur="1.0"/> it's it's a subset of <pause dur="0.2"/> of all the the # additions that you do and those are the ones you probably use <pause dur="0.4"/> most frequently <pause dur="4.3"/><kinesic desc="changes transparency" iterated="y" dur="19"/> okay <pause dur="15.1"/> 
now <pause dur="1.1"/> of course <pause dur="2.4"/> what if you've what got two <pause dur="0.3"/> variables in memory <pause dur="2.2"/> okay what i've i've been doing at the moment i've had a variable in a register <pause dur="0.4"/> and a variable <pause dur="0.3"/> in a memory location <pause dur="1.5"/> okay <pause dur="0.5"/> now <pause dur="2.3"/> you can't <pause dur="1.8"/> have both a source and destination <pause dur="0.3"/> as memory variables the only instruction you can is move <pause dur="0.4"/> and you can't <pause dur="0.4"/> do it <pause dur="0.4"/> with the rest <pause dur="1.7"/> so how are we going to do it <pause dur="0.4"/> well what we've got to do <pause dur="0.2"/> is move the value of <pause dur="0.2"/> one of the <trunc>varia</trunc> # variables into a register <pause dur="0.4"/> do and do the addition <pause dur="2.7"/> okay so <pause dur="0.3"/> essentially we've broken it down <pause dur="0.3"/> into <pause dur="0.3"/> # <pause dur="0.5"/> two things where <pause dur="17.0"/> so we have to <pause dur="0.3"/> break it down into a simpler set of instructions but we haven't got <pause dur="0.2"/> a single instruction to do it <pause dur="0.6"/> so we have to <pause dur="1.9"/> this is why <pause dur="2.4"/> pretty much the <pause dur="0.3"/> data register there </u><pause dur="1.5"/> <u who="sm0717" trans="pause"> can i just </u><u who="nm0716" trans="latching"> yeah </u><pause dur="0.6"/> <u who="sm0717" trans="pause"> the second line should be add shouldn't it </u><pause dur="0.7"/> <u who="nm0716" trans="pause"> sorry </u><pause dur="0.2"/> <u who="sm0717" trans="pause"> on the second line should it be add </u><pause dur="1.8"/> <u who="nm0716" trans="pause"> yes <pause dur="8.9"/> thank you <pause dur="10.6"/> okay <pause dur="1.0"/> now <pause dur="0.6"/> in a very <pause dur="0.2"/> simple form we're using <pause dur="0.2"/> the <pause dur="0.2"/> data register as an accumulator as a <pause dur="0.4"/> temporary <pause dur="0.2"/> scratch <pause dur="0.7"/> piece of <pause dur="0.2"/> <trunc>me</trunc> # <pause dur="1.1"/> a temporary scratch <pause dur="0.4"/> variable <pause dur="0.2"/> to <pause dur="0.8"/> perform the addition <pause dur="1.9"/> so let's look 
at <pause dur="0.9"/> a rather more complicated form <pause dur="0.3"/> all right well <pause dur="0.4"/> not too complicated but <pause dur="0.3"/> here we are <pause dur="0.4"/> we've got <pause dur="1.0"/> A-plus-B-plus-C-minus-eighty-seven <pause dur="4.3"/> so <pause dur="2.0"/> essentially <pause dur="0.5"/> what we're going to have to do <pause dur="0.2"/> we start off <pause dur="2.6"/> assigning <pause dur="1.5"/> A <pause dur="0.2"/> to D-nought <pause dur="8.1"/> then <pause dur="0.3"/> add <pause dur="2.6"/> B <pause dur="0.4"/> to D-nought <pause dur="1.5"/> how about having a go at the next two <pause dur="2.3"/> yeah <pause dur="0.6"/> how about trying to continue <pause dur="0.3"/> you you got <pause dur="0.4"/> you see what i've done here i i've <pause dur="0.2"/> added <pause dur="0.3"/> i now want to add C <pause dur="0.7"/> # <pause dur="0.4"/> minus-eighty-seven <pause dur="0.2"/> from <pause dur="0.2"/> D-nought so have just have a go </u><pause dur="1:34.3"/><event desc="doing task set" iterated="y" n="ss" dur="1:34"/> <u who="nm0716" trans="pause"> okay <pause dur="0.7"/> well <pause dur="3.6"/> we add C <pause dur="2.0"/> to D-nought <pause dur="1.2"/> we then subtract <pause dur="1.9"/> eighty-seven <pause dur="0.9"/> from D-nought <pause dur="0.8"/> and then we assign <pause dur="0.8"/> the accumulator D-nought <pause dur="0.2"/> to the sum <pause dur="3.3"/> now that <pause dur="0.6"/> is just a straightforward way <pause dur="0.2"/> of doing it <pause dur="0.3"/> okay it's it's it's a <pause dur="0.4"/> it's obvious <pause dur="0.2"/> well <pause dur="0.5"/> you know you break it down into components and we we we do that <pause dur="0.8"/> there is a more sophisticated way of doing it which # <pause dur="0.8"/> <trunc>m</trunc> <pause dur="0.5"/> might be those who are <trunc>re</trunc> really interested <vocal desc="clears throat" iterated="n"/><pause dur="0.8"/> might like to look up a book on a compiler <pause dur="0.7"/> all right <pause dur="0.9"/> how <pause dur="0.7"/> there is a general <pause dur="0.4"/> method <pause dur="0.6"/> for <pause dur="0.8"/> # <pause dur="0.6"/> evaluating expressions <pause dur="0.6"/> 
with arbitrary sets of brackets and operators and <pause dur="0.2"/> and so on <pause dur="0.3"/> all right <pause dur="1.1"/> not <pause dur="0.2"/> going to go into it here <pause dur="0.7"/> but it is interesting <pause dur="0.6"/> how to say <pause dur="1.1"/> 'cause you can write <pause dur="0.2"/> there's <pause dur="0.5"/> a <pause dur="0.5"/> pretty complicated expression before the compiler will give up <pause dur="2.4"/> i don't suggest you do you can't read it i mean i i tend to <pause dur="0.3"/> break <pause dur="0.2"/> expressions up <pause dur="0.2"/> just so that i can read what's going on <pause dur="0.3"/> but <pause dur="0.4"/> a compiler <pause dur="0.5"/> has to have a general way <pause dur="0.2"/> and <pause dur="0.3"/> in fact what it does <pause dur="0.4"/> it <pause dur="0.3"/> # <pause dur="0.6"/> uses <pause dur="0.2"/> a stack <pause dur="0.3"/> method to <pause dur="0.2"/> to do it <pause dur="0.2"/> and <pause dur="0.4"/> for those who are interested any book in compilers will have a little section <pause dur="0.6"/> on this <pause dur="0.6"/> so i'm not pretending to be a real compiler at this point <pause dur="0.4"/> we'll just take simple expressions and attack them in an obvious way <pause dur="3.3"/> okay looks like any questions then <pause dur="0.2"/> # <pause dur="5.7"/> looks like you're off for five minutes early so <pause dur="0.2"/> there we go <pause dur="1.1"/> it must go quicker than i thought 
</u></body>
</text></TEI.2>