<?xml version="1.0"?>
<!DOCTYPE TEI.2 SYSTEM "base.dtd">
<TEI.2><teiHeader>	
<fileDesc>
<titleStmt>
<title>Recursion</title></titleStmt>
<publicationStmt><distributor>BASE and Oxford Text Archive</distributor>
<idno>pslct010</idno>	
<availability><p>The British Academic Spoken English (BASE) corpus was developed at the
Universities of Warwick and Reading, under the directorship of Hilary Nesi
(Centre for English Language Teacher Education, Warwick) and Paul Thompson
(Department of Applied Linguistics, Reading), with funding from BALEAP,
EURALEX, the British Academy and the Arts and Humanities Research Board. The
original recordings are held at the Universities of Warwick and Reading, and
at the Oxford Text Archive and may be consulted by bona fide researchers
upon written application to any of the holding bodies.
The BASE corpus is freely available to researchers who agree to the
following conditions:</p>
<p>1. The recordings and transcriptions should not be modified in any
way</p>
<p>2. The recordings and transcriptions should be used for research purposes
only; they should not be reproduced in teaching materials</p>
<p>3. The recordings and transcriptions should not be reproduced in full for
a wider audience/readership, although researchers are free to quote short
passages of text (up to 200 running words from any given speech event)</p>
<p>4. The corpus developers should be informed of all presentations or
publications arising from analysis of the corpus</p><p>
Researchers should acknowledge their use of the corpus using the following
form of words:
The recordings and transcriptions used in this study come from the British
Academic Spoken English (BASE) corpus, which was developed at the
Universities of Warwick and Reading under the directorship of Hilary Nesi
(Warwick) and Paul Thompson (Reading). Corpus development was assisted by
funding from the Universities of Warwick and Reading, BALEAP, EURALEX, the
British Academy and the Arts and Humanities Research Board. </p></availability>
</publicationStmt>
<sourceDesc>
<recordingStmt>
<recording dur="00:50:14" n="7069">
<date>10/11/1998</date><equipment><p>video</p></equipment>
<respStmt><name>BASE team</name>
</respStmt></recording></recordingStmt></sourceDesc></fileDesc>
<profileDesc>
<langUsage><language id="en">English</language>
</langUsage>
<particDesc>
<person id="nm0718" role="main speaker" n="n" sex="m"><p>nm0718, main speaker, non-student, male</p></person>
<person id="sm0719" role="participant" n="s" sex="m"><p>sm0719, participant, student, male</p></person>
<person id="sm0720" role="participant" n="s" sex="m"><p>sm0720, participant, student, male</p></person>
<person id="sm0721" role="participant" n="s" sex="m"><p>sm0721, participant, student, male</p></person>
<person id="sm0722" role="participant" n="s" sex="m"><p>sm0722, participant, student, male</p></person>
<person id="sm0723" role="participant" n="s" sex="m"><p>sm0723, participant, student, male</p></person>
<personGrp id="ss" role="audience" size="l"><p>ss, audience, large group </p></personGrp>
<personGrp id="sl" role="all" size="l"><p>sl, all, large group</p></personGrp>
<personGrp role="speakers" size="8"><p>number of speakers: 8</p></personGrp>
</particDesc>
<textClass>
<keywords>
<list>
<item n="speechevent">Lecture</item>
<item n="acaddept">Computer Science</item>
<item n="acaddiv">ps</item>
<item n="partlevel">UG</item>
<item n="module">unknown</item>
</list></keywords>
</textClass> 
</profileDesc></teiHeader><text><body>
<u who="nm0718"> how many people <pause dur="0.2"/> looked at the examples that we covered last time on <pause dur="1.2"/> inheritance and abstraction <pause dur="1.3"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people didn't <pause dur="3.2"/><kinesic desc="put hands up" iterated="n" n="ss"/> good <pause dur="4.6"/><event desc="turns on overhead projector" iterated="n"/> we looked at <pause dur="0.5"/> two <pause dur="0.2"/> different ways in which you could <pause dur="11.3"/> two different ways in which you could have <pause dur="1.2"/> subclasses <pause dur="0.4"/> of other classes so we looked at one case where we had <pause dur="3.5"/> an alcoholic drink class <pause dur="0.2"/> and then we had <pause dur="0.8"/> a subclass of wine <pause dur="0.4"/> which was a particular case of an alcoholic drink <pause dur="1.5"/> okay and that was the example we've been working through over the <pause dur="0.6"/> a week or so <pause dur="1.2"/> and then the last thing that we looked at last time was <pause dur="0.6"/> having a generic <pause dur="2.0"/> abstract class <pause dur="4.1"/><event desc="students enter room" iterated="n" n="ss"/> there are seats around here <pause dur="0.8"/> round the other side if you want to come down <pause dur="6.2"/> the other thing that we looked at was <pause dur="0.9"/> an abstract class which could have several different possible cases <pause dur="0.5"/> of which there could be beer <pause dur="0.4"/> wine <pause dur="0.2"/> spirits and so on <pause dur="0.4"/> and they both do <trunc>equiv</trunc> roughly the same job <pause dur="2.2"/> okay <pause dur="0.3"/> so those are alternative ways of looking at <pause dur="0.6"/> inheritance and abstraction <pause dur="0.6"/> but the second one has this <pause dur="0.3"/> 
generic class and we'll look at that <pause dur="0.7"/> a little bit later <pause dur="0.7"/> in the course <pause dur="0.5"/> and we'll see why that's <pause dur="0.8"/> quite useful in allowing you to <pause dur="0.2"/> to do <pause dur="0.4"/> a new <pause dur="0.9"/> category of things on <pause dur="0.5"/> # <pause dur="0.9"/> the things that are different but <pause dur="0.4"/> are <pause dur="1.2"/> broadly the same <pause dur="0.3"/> have this <pause dur="0.2"/> broad abstract structure that's the same <pause dur="3.0"/> how many people understood the difference between the two ways of doing <pause dur="1.2"/> inheritance <pause dur="1.9"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people didn't <pause dur="3.6"/><kinesic desc="put hands up" iterated="n" n="ss"/> of those people that didn't how many of you looked at the notes and tried to <pause dur="0.6"/> work through an example <pause dur="3.8"/> okay <pause dur="4.1"/><kinesic desc="reveals covered part of transparency" iterated="n"/> the one thing that we didn't do last time was the final <pause dur="1.3"/> keyword <pause dur="0.9"/> final <pause dur="0.9"/> modifier <pause dur="0.8"/> and we encountered the final modifier over <pause dur="0.6"/> several previous cases several previous <pause dur="0.6"/> slides <pause dur="1.0"/> when we were looking at modifiers <pause dur="0.4"/> how many of you have done Pascal <pause dur="1.9"/><kinesic desc="put hands up" iterated="n" n="ss"/> okay so you'll know that in Pascal <pause dur="1.5"/> there are things called constants <pause dur="0.6"/> okay and in general there are things <pause dur="1.0"/> that are constant that have constant value <pause dur="0.4"/> like <pause dur="0.7"/> pi <pause dur="1.4"/> which is three-point-one-four-one <pause dur="0.6"/> and whatever it is <pause dur="0.5"/> # and there 
can be various other constants and i've avoided this up to now 'cause we can deal with <pause dur="0.7"/> all the uses of the final keyword # in one <pause dur="0.5"/> chunk <pause dur="1.8"/> and <pause dur="0.6"/> when you have a variable <pause dur="2.2"/> just like any other variable <pause dur="0.4"/> and you know that its value isn't going to change <pause dur="0.6"/> throughout a program <pause dur="1.3"/> then <pause dur="0.4"/> by adding the keyword final <pause dur="0.4"/> at the front of the declaration <pause dur="1.0"/> you can say that that is a constant <pause dur="0.3"/> so final int lucky number <pause dur="0.5"/> equals seven <pause dur="1.9"/> which is assigned <pause dur="7.1"/> is assigned the constant value <pause dur="0.2"/> seven and that value will never change throughout a program <pause dur="1.2"/> i was going to try and turn down the lights can you see this at the back <pause dur="1.5"/> good <pause dur="0.3"/> okay <pause dur="0.7"/> okay so that's <pause dur="0.4"/> fairly straightforward <pause dur="0.4"/> but in classes <pause dur="0.3"/> in objects in classes it becomes rather different it has a very different meaning <pause dur="2.9"/><kinesic desc="reveals covered part of transparency" iterated="n"/> and that is that you can't <pause dur="0.5"/> override <pause dur="1.1"/> a method that is final <pause dur="0.4"/> in a subclass <pause dur="2.9"/> okay <pause dur="0.3"/> so <pause dur="0.3"/> for example <pause dur="0.2"/> one thing that you've seen several times before is the two-string method <pause dur="0.7"/> the two-string method <pause dur="0.6"/> in the previous 
examples that we've seen <pause dur="0.2"/> allows you to print out <pause dur="1.0"/> a representation of an object <pause dur="0.7"/> okay <pause dur="0.4"/> and whenever you define <pause dur="0.6"/> a <pause dur="0.2"/> two-string method in your objects in your classes <pause dur="1.9"/> that overrides the previous two-string method the two-string method that is there by default <pause dur="1.0"/> you've seen the equals method we defined an equals method last time <pause dur="1.0"/> okay and it's used with strings <pause dur="0.4"/> and there's a default equals method <pause dur="0.3"/> and these things are overridden <pause dur="0.5"/> so that when you define your own equals method it will override <pause dur="0.3"/> any previous equals methods <pause dur="0.3"/> that exist and there is a default that exists <pause dur="0.5"/> but you will <pause dur="0.4"/> override that <pause dur="1.3"/> what this says is that <pause dur="0.5"/> if you have a final <pause dur="1.1"/> keyword with a method <pause dur="0.2"/> definition <pause dur="0.6"/> in a class <pause dur="0.3"/> you will not be able to override it <pause dur="0.7"/> okay so if <pause dur="0.5"/> in the default definition of equals or two-string <pause dur="0.7"/> this keyword final <pause dur="0.3"/> was there <pause dur="0.7"/> then we wouldn't be able to override that with our own definitions of <pause dur="0.7"/> equals and two-string <pause dur="2.5"/> okay so that's all that final means <pause dur="1.3"/> and <pause dur="0.4"/> we've seen several 
different modifiers we've seen static and private as well <pause dur="0.8"/> which are both <pause dur="0.4"/> final <pause dur="1.0"/> by implication <pause dur="0.4"/> so although <pause dur="0.4"/> they don't have final in them <pause dur="0.5"/> they are <pause dur="0.2"/> final methods <pause dur="0.5"/> you can't override things <pause dur="0.8"/><kinesic desc="reveals covered part of transparency" iterated="n"/> the reason for using <pause dur="0.2"/> final is that <pause dur="0.4"/> if the compiler knows <pause dur="0.3"/> that it's never going to have to redefine it it's never going to have to do anything more <pause dur="2.7"/> then it can optimize the code when it's converting it to <pause dur="0.8"/> the thing that it actually executes <pause dur="0.3"/> it can try and make it run quicker faster better <pause dur="0.9"/> okay <pause dur="1.1"/> without that knowledge without knowing that we won't override it it's very difficult to be able to do that <pause dur="0.4"/> so it's quite useful 'cause it allows the compiler <pause dur="0.3"/> to optimize code <pause dur="3.3"/> and because <pause dur="0.4"/> of the way it works which is all really a consequence of the fact that you can't override things <pause dur="1.0"/> a final class can't be a superclass <pause dur="0.7"/> so in the previous example the <trunc>abs</trunc> <pause dur="0.2"/> alcoholic drink <pause dur="0.4"/> the abstract <trunc>alc</trunc> alcoholic drink <pause dur="0.7"/> and the generic <pause dur="1.0"/> alcoholic drink <pause dur="1.3"/> you can't have final for the methods that are <pause dur="0.9"/> sorry for the 
class <pause dur="1.2"/> # that will then <pause dur="0.6"/> # <pause dur="1.5"/> generate subclasses like wine <pause dur="0.9"/> and beer and so on <pause dur="2.7"/> okay <pause dur="2.7"/> any questions <pause dur="1.6"/> how many people understood that <pause dur="1.4"/><kinesic desc="put hands up" iterated="n" n="ss"/> okay <pause dur="0.5"/> good <pause dur="1.3"/><kinesic desc="changes transparency" iterated="y" dur="40"/> that's it that's classes <pause dur="0.6"/> they're done they're finished if you have questions problems ask your seminar tutor <pause dur="0.4"/> or ask me later <pause dur="0.7"/> okay but that's it <pause dur="0.2"/> that's essentially all we're going to do on classes and objects <pause dur="2.6"/> okay so i expect you now to know it <pause dur="2.6"/> and you have a test <pause dur="2.0"/> gosh is it <pause dur="0.2"/> next week <pause dur="2.2"/><kinesic desc="nod heads" iterated="n" n="ss"/> someone's nodding <pause dur="0.3"/> test next week how many of you remember you have a test next week <pause dur="0.9"/><kinesic desc="put hands up" iterated="n" n="ss"/> hurray next Thursday i think <pause dur="0.2"/> a test <pause dur="0.3"/> in L-three <pause dur="1.3"/> the second test <pause dur="4.8"/> the second test for this course worth five per cent of the marks <pause dur="9.5"/> okay <pause dur="2.0"/> so <pause dur="10.1"/> the key thing that we're going to do today <pause dur="0.6"/> is to look at recursion <pause dur="1.5"/> and recursion is a very simple <pause dur="0.3"/> but powerful <pause dur="0.7"/> concept <pause dur="1.1"/> but it's also something that people find quite difficult typically to 
deal with <pause dur="1.7"/> okay and recursion <pause dur="2.1"/> just refers to <pause dur="0.3"/> something that refers to itself <pause dur="1.0"/> and this is repeated <pause dur="0.2"/> over and over again <pause dur="0.7"/> by referring to itself <pause dur="1.1"/> and so this <pause dur="1.1"/> picture <pause dur="1.6"/> of a television screen <pause dur="0.4"/> within a television screen within a television screen <pause dur="0.6"/> is a recursive picture <pause dur="0.9"/> because it just keeps on going <pause dur="0.8"/> until some point at which we can't see it any more <pause dur="0.9"/> okay and that's <pause dur="0.4"/> all <pause dur="1.4"/> that recursion is it's just <pause dur="0.2"/> defining something in terms of itself <pause dur="0.2"/> so this T-V picture contains a T-V picture <pause dur="0.8"/> which in turn contains a T-V picture and so on <pause dur="3.4"/><kinesic desc="changes transparency" iterated="y" dur="9"/> how many people <pause dur="6.7"/> have heard of the Towers of Hanoi <pause dur="1.4"/><kinesic desc="put hands up" iterated="n" n="ss"/> wow <pause dur="2.5"/> how many people can solve the Towers of Hanoi <pause dur="2.3"/><kinesic desc="put hands up" iterated="n" n="ss"/> mm <pause dur="0.9"/> this is my <pause dur="1.3"/><kinesic desc="brings out prop" iterated="n"/> i i <pause dur="0.7"/> cheated earlier today <pause dur="0.5"/> because i # <pause dur="0.8"/> i pretended to be a student <pause dur="0.6"/> in the # <pause dur="0.6"/> writing course that that <pause dur="0.6"/> C-S take <pause dur="1.0"/> # and there were lots of exciting things happening in <pause dur="0.6"/> in that there was music being played 
and <pause dur="1.0"/> tenners being thrown up scrunched into balls and thrown <pause dur="0.6"/> into the corner <pause dur="1.1"/> and it continues <pause dur="0.2"/> the excitement of the day <pause dur="0.8"/> 'cause we have a <pause dur="2.6"/> a prop <pause dur="1.8"/> which is my <pause dur="2.0"/> Towers of Hanoi <pause dur="1.4"/> okay <pause dur="0.4"/> Towers of Hanoi <pause dur="0.5"/> three poles <pause dur="0.6"/> with <pause dur="0.4"/> a number of discs <pause dur="0.9"/> on one end <pause dur="0.3"/> and the idea is to take <kinesic desc="indicates discs" iterated="n"/> these three discs <pause dur="0.2"/> and to move them all <pause dur="0.5"/> to the other end <pause dur="1.7"/><kinesic desc="indicates pole" iterated="n"/> okay <pause dur="0.6"/> third pole <pause dur="2.6"/> by placing taking one at a time <pause dur="0.5"/><kinesic desc="moves disc" iterated="n"/> moving them across <pause dur="0.3"/> but not putting a smaller disc <pause dur="2.4"/> a larger disc onto a smaller disc <pause dur="0.4"/> okay so <pause dur="0.4"/><kinesic desc="moves disc" iterated="n"/> that would be an illegal move in the Towers of Hanoi problem <pause dur="0.2"/> okay we can't do that <pause dur="0.2"/> we can only move <kinesic desc="moves discs" iterated="y" dur="5"/> smaller discs onto <pause dur="0.5"/> larger discs <pause dur="1.7"/> okay so we could solve it in various ways it could be <pause dur="0.5"/> quite tricky could be difficult <pause dur="0.6"/> but <pause dur="1.0"/> it's called the Towers of Hanoi because <pause dur="0.4"/> apparently <pause dur="1.3"/> there's a # a monastery somewhere in the Far East <pause dur="0.4"/> # i am told it's <pause dur="1.4"/> in what is 
now <pause dur="0.3"/> Hanoi <pause dur="0.9"/> # in Vietnam <pause dur="0.6"/> but i don't know if that's right or not <pause dur="0.2"/> # <pause dur="0.8"/> and the monks in this monastery <pause dur="0.5"/> # <pause dur="0.3"/> have a <pause dur="1.3"/> problem like this with sixty-four discs <pause dur="1.2"/> okay so they've got <pause dur="0.2"/> a stack of sixty-four discs <pause dur="0.3"/> and they make a move <pause dur="0.3"/> every day they move one disc onto a different pole every day <pause dur="0.9"/> and supposedly when the <pause dur="0.9"/> monks finish the problem <pause dur="1.4"/> the world will come to an end <pause dur="0.9"/> so there are these monks somewhere in the Far East <pause dur="0.5"/> taking <pause dur="0.4"/><kinesic desc="moves disc" iterated="n"/> a disc at a time <pause dur="0.5"/> and moving it across <pause dur="0.3"/> and whenever they finish the problem <pause dur="0.4"/> # <pause dur="1.7"/> the world will end now <pause dur="0.5"/> the good news is that <pause dur="0.2"/> that will take an incredibly long time even if they <pause dur="2.4"/> even if they do it in the most sensible way possible <pause dur="0.7"/> so <pause dur="0.2"/> # <pause dur="0.3"/> we still have a while to go yet <pause dur="0.7"/> but <pause dur="3.6"/><kinesic desc="moves discs" iterated="y" dur="3"/> the good thing about this particular problem is that it's a very good example of how to <pause dur="2.3"/> how recursion <pause dur="0.3"/> can make something that looks quite complicated very very simple <pause dur="1.7"/> okay so <pause dur="1.7"/><kinesic desc="removes discs from poles" iterated="n"/> 
there's a very simple way to do it if we have one disc <pause dur="0.6"/> how many people could solve the problem with one disc <pause dur="1.9"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people couldn't <pause dur="1.6"/> one disc is very easy 'cause <kinesic desc="moves disc" iterated="n"/> there's no problem you can move it straight to the end <pause dur="2.2"/> very easy <pause dur="0.7"/> now you get the people that didn't put up their hands <pause dur="1.0"/><kinesic desc="adds disc to pole" iterated="n"/> you can do it with <pause dur="0.2"/> two discs <pause dur="0.6"/> how many people can solve it with two <pause dur="1.1"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people can't <pause dur="2.5"/> okay so two is very easy <kinesic desc="moves discs" iterated="y" dur="6"/> 'cause we just use the spare pole in the middle <pause dur="1.9"/> and then move it across <pause dur="1.2"/> and then do that <pause dur="0.2"/> very easy <pause dur="0.4"/> how many people can do it with three discs <pause dur="2.2"/><kinesic desc="put hands up" iterated="n" n="ss"/> so <pause dur="0.7"/><kinesic desc="adds disc to pole" iterated="n"/><event desc="hands prop to student" iterated="n"/> this is when i get someone to do it <pause dur="0.2"/> who did you did you put your hand up </u><pause dur="0.4"/> <u who="sm0719" trans="pause"> yeah </u><pause dur="0.3"/> <u who="nm0718" trans="pause"> go for it <pause dur="1.0"/> they're they're not in the right order by the way </u><u who="sm0719" trans="overlap"> yeah </u><u who="nm0718" trans="overlap"> so you 
can sort them out first <pause dur="4.4"/><kinesic desc="moves discs" iterated="y" n="sm0719" dur="30"/> okay so </u><pause dur="5.2"/> <u who="ss" trans="pause"> <gap reason="inaudible, multiple speakers" extent="15 sec"/></u><u who="nm0718" trans="overlap"> <trunc>st</trunc> <pause dur="2.6"/> you need to <trunc>st</trunc> <pause dur="0.6"/> right <vocal desc="laughter" iterated="y" n="sm0719" dur="1"/> <pause dur="0.3"/> you need to start with <trunc>st</trunc> <trunc>st</trunc> <pause dur="0.3"/><kinesic desc="moves discs" iterated="y" dur="5"/> shall we start again </u><u who="sm0719" trans="latching"> yeah <pause dur="0.2"/> go on </u><u who="nm0718" trans="overlap"> i dare you </u><u who="sm0719" trans="latching"> let's go try again </u><pause dur="1.1"/> <u who="nm0718" trans="pause"> start with them at one end <pause dur="0.8"/><kinesic desc="moves discs" iterated="y" n="sm0719" dur="29"/> that might be easier </u><pause dur="1.2"/> <u who="ss" trans="pause"> <gap reason="inaudible, multiple speakers" extent="23 sec"/><kinesic desc="applause" iterated="y" n="sm0719" dur="4"/></u><u who="nm0718" trans="overlap"> well done <pause dur="2.5"/> thank you <pause dur="0.8"/> # <pause dur="1.3"/> it it's <pause dur="0.6"/> that that was i'm i'm <pause dur="0.2"/> dead impressed with that actually <pause dur="0.2"/> because it's very difficult doing it when there are lots of people watching but <pause dur="0.5"/> # <pause dur="1.4"/> can anyone do it with four <pause dur="1.6"/><kinesic desc="put hands up" iterated="n" n="ss"/> too far away i can't reach you anyone <pause dur="1.7"/> we'll have a go at four in a in a in a bit <pause dur="0.6"/> # <pause dur="0.4"/> but <pause dur="0.6"/><kinesic desc="moves discs" iterated="y" dur="6"/> if we break 
this problem down into separate parts it's very simple <pause dur="0.6"/> okay what we're doing is <pause dur="0.5"/> we're saying <pause dur="1.1"/> the <pause dur="2.7"/> the problem with <pause dur="0.6"/> three discs can be broken down into <pause dur="0.8"/> the problem with two discs <pause dur="0.2"/> and then one disc <pause dur="0.3"/> so <pause dur="0.3"/> we need to move <kinesic desc="indicates discs" iterated="n"/> these three discs <pause dur="0.3"/> over to here <pause dur="0.6"/><kinesic desc="indicates pole" iterated="n"/>  and we can say <kinesic desc="moves discs" iterated="y" dur="9"/> if we move <pause dur="0.3"/> two discs across <pause dur="2.3"/> okay we can just move the one across there <pause dur="0.9"/> and then we can move the two across <pause dur="0.6"/> to there <pause dur="1.5"/> okay but we can't move two discs across 'cause we can only move one disc at a time <pause dur="0.9"/><kinesic desc="moves discs" iterated="n"/> so the problem is <pause dur="1.1"/> then <pause dur="0.3"/> how do we move two discs from here <kinesic desc="indicates discs" iterated="n"/><pause dur="0.4"/> to here <pause dur="1.6"/><kinesic desc="indicates pole" iterated="n"/> well that's easy 'cause we know we can just move two discs from one pole to another pole <pause dur="0.9"/> using the spare pole <pause dur="0.4"/><kinesic desc="indicates pole" iterated="n"/> so we want to move <kinesic desc="indicates pole" iterated="n"/> two from here to here <kinesic desc="indicates pole" iterated="n"/> using this <kinesic desc="indicates pole" iterated="n"/> spare pole <pause dur="0.6"/> and <pause dur="1.7"/><kinesic desc="moves discs" iterated="y" dur="4"/> we can do that <pause dur="0.7"/> pretty easily <pause dur="1.6"/> 'cause most of you said you could do it <pause dur="0.4"/> okay <pause dur="0.2"/> that's fairly easy <pause dur="0.4"/> the next thing that we can do <pause dur="0.5"/><kinesic desc="moves disc" iterated="n"/> directly we can 
move this disc across to here <pause dur="1.2"/> and then the next problem that we have is to take <pause dur="0.4"/><kinesic desc="indicates discs" iterated="n"/> these two <pause dur="0.8"/> and move them across to <kinesic desc="indicates pole" iterated="n"/>  this pole <pause dur="1.6"/> using the <kinesic desc="indicates pole" iterated="n"/> spare pole <pause dur="1.2"/> and we've just done that already <pause dur="0.4"/> the other way round <pause dur="0.7"/><kinesic desc="moves discs" iterated="y" dur="5"/> and that's <pause dur="1.2"/> fairly easy and straightforward <pause dur="2.3"/> so we moved it across <pause dur="2.3"/> okay <pause dur="1.7"/> does that make sense <pause dur="2.5"/> how many people <pause dur="0.3"/> think it doesn't make sense <pause dur="2.4"/> how many people think it does <pause dur="0.9"/><kinesic desc="put hands up" iterated="n" n="ss"/> hurray <pause dur="0.6"/><kinesic desc="adds discs to pole" iterated="n"/> okay <pause dur="0.7"/> four discs <pause dur="1.8"/> the problem with four discs is the same as the problem with three discs <pause dur="0.6"/> except <pause dur="0.4"/> we're now going to move <pause dur="0.7"/><kinesic desc="moves discs" iterated="y" dur="8"/> three at a time <pause dur="1.4"/> to the middle one <pause dur="0.5"/> then the big one <pause dur="0.9"/> all the way to the end <pause dur="0.6"/> then three <pause dur="0.6"/> across <pause dur="1.0"/> but we can't move three <pause dur="0.4"/> so we have to do it in terms of <pause dur="2.2"/><kinesic desc="moves discs" iterated="n"/> two <pause dur="0.8"/> so if we were starting with this one and moving them across we would have to find a way of moving <pause dur="0.5"/> three discs to here <pause dur="1.3"/><kinesic desc="indicates pole" iterated="n"/> okay and we'd have to find a way of <pause dur="0.4"/> doing that in terms of two which would be done by moving two discs to here <pause dur="1.8"/><kinesic desc="indicates pole" iterated="n"/>  
and then we'd have to find a way of doing that which would be by moving <pause dur="0.4"/><kinesic desc="moves discs" iterated="y" dur="4"/> one to here <pause dur="1.2"/> one to there <pause dur="0.6"/> one to there so we've now moved two discs <pause dur="1.7"/><kinesic desc="moves discs" iterated="y" dur="7"/> if we go back trying to move <pause dur="1.2"/> the two discs back onto here <pause dur="3.3"/> we're okay <pause dur="1.2"/> we can move this one directly <pause dur="0.8"/><kinesic desc="moves disc" iterated="n"/> and now we're back with the problem of moving <kinesic desc="indicates discs" iterated="n"/> these three <pause dur="0.4"/> from here to here <pause dur="1.1"/><kinesic desc="indicates pole" iterated="n"/>  okay and we can't do that directly so we have to move <pause dur="0.6"/> two <pause dur="0.2"/> from <kinesic desc="indicates pole" iterated="n"/> here to <kinesic desc="indicates pole" iterated="n"/> here <pause dur="1.5"/> and then move the <pause dur="0.2"/> big one directly <kinesic desc="indicates pole" iterated="n"/> onto this one <pause dur="0.3"/> and then move the two back <kinesic desc="indicates pole" iterated="n"/> <pause dur="0.2"/><kinesic desc="moves discs" iterated="y" dur="6"/> so we have to go <pause dur="1.2"/> two discs <pause dur="0.4"/> to here <pause dur="2.3"/> okay those are our two discs <pause dur="0.5"/><kinesic desc="moves disc" iterated="n"/> this one moves directly <pause dur="0.2"/> and now we're back with the problem of moving <pause dur="0.5"/> two from here <kinesic desc="indicates pole" iterated="n"/> <pause dur="0.4"/> to here <pause dur="1.6"/><kinesic desc="indicates pole" iterated="n"/> <kinesic desc="moves discs" iterated="y" dur="4"/> using the spare pole <pause dur="2.4"/> okay <pause dur="1.8"/> how many people think they can do it with five discs <pause dur="2.2"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people think they can do it with six discs <pause dur="1.2"/><kinesic desc="put hands up" iterated="n" n="ss"/> okay <pause dur="0.9"/><vocal desc="laughter" iterated="y" dur="1"/><pause dur="0.3"/> we don't have time for six 
discs or probably even five discs but it's exactly the same thing <pause dur="0.6"/> the problem to five discs <pause dur="0.6"/> the problem with five discs is the same <pause dur="0.4"/> thing as <kinesic desc="moves discs" iterated="y" dur="10"/> moving four <pause dur="1.1"/> to the spare pole <pause dur="1.1"/> one across <pause dur="1.5"/> and four <pause dur="1.0"/> back across and we can do the <pause dur="1.4"/> problem of moving four from one <kinesic desc="indicates pole" iterated="n"/> to the <kinesic desc="indicates pole" iterated="n"/> middle by using the <kinesic desc="indicates pole" iterated="n"/> spare pole <pause dur="0.5"/> and then we <pause dur="0.2"/> work that one out in terms of moving three <pause dur="0.5"/> and we work that one out in terms of using two <pause dur="7.1"/> any questions about that <pause dur="5.3"/> so <pause dur="0.3"/> people you all think you can do it in <trunc>f</trunc> <pause dur="0.3"/> with three discs right <pause dur="0.6"/> anyone does does anyone think they couldn't do it with three discs <pause dur="2.0"/> does anyone think they couldn't do it with four discs if they had enough time <pause dur="2.6"/><kinesic desc="put hands up" iterated="n" n="ss"/> is that is that 'cause <pause dur="0.2"/> you don't understand how it's done or because <pause dur="1.8"/> you'd get lost </u><pause dur="0.3"/> <u who="sm0720" trans="pause"> did you say could or couldn't </u><pause dur="0.4"/> <u who="nm0718" trans="pause"> sorry </u><pause dur="0.2"/> <u who="sm0720" trans="pause"> did you say could or couldn't </u><pause dur="0.2"/> <u who="nm0718" trans="pause"> couldn't do it <pause dur="0.8"/> in four <pause dur="0.4"/> couldn't do couldn't <pause dur="0.2"/> move four discs across <pause dur="5.8"/> how many people <trunc>s</trunc> think they couldn't do it in with four discs <pause dur="0.4"/> <unclear>can i have it</unclear> hands up again <pause dur="1.2"/><kinesic desc="put hands up" iterated="n" n="ss"/> 
is that <pause dur="0.4"/> if you keep your hands up please <pause dur="0.3"/> # don't want to # is that because it's <pause dur="0.3"/> the problem is difficult <pause dur="2.1"/> or is it because <pause dur="0.8"/> do you think you'd you'd get lost on on the way <pause dur="6.6"/> no answers <pause dur="3.3"/> okay <pause dur="1.7"/> i'll assume that means that you can all do it <pause dur="1.1"/> and it's a very simple thing to do <pause dur="1.3"/><kinesic desc="reveals covered part of transparency" iterated="n"/> the solution <pause dur="0.3"/> the general solution to this is <pause dur="0.6"/> simply to move the top <pause dur="0.2"/> N-minus-one discs <pause dur="0.8"/> from the source <pause dur="1.0"/> to the auxiliary if we have a source <pause dur="0.6"/><kinesic desc="indicates pole" iterated="n"/> tower <pause dur="0.3"/><kinesic desc="indicates pole" iterated="n"/> a destination tower <pause dur="0.6"/><kinesic desc="indicates pole" iterated="n"/> and an auxiliary tower <pause dur="0.9"/> okay the auxiliary being the one that we <pause dur="0.2"/> don't want to get things to but the one we're going to use <pause dur="0.5"/> in the middle <pause dur="0.6"/><kinesic desc="moves discs" iterated="n"/> we simply move <pause dur="0.5"/> the top N-minus-one discs to the auxiliary <pause dur="4.6"/><kinesic desc="reveals covered part of transparency" iterated="n"/> and we can use the destination to do that <pause dur="1.9"/><kinesic desc="moves disc" iterated="n"/> the next thing we do is move the bottom one <pause dur="0.6"/> to the destination <pause dur="2.9"/><kinesic desc="reveals covered part of transparency" iterated="n"/> and the next thing is to move the <pause dur="0.8"/> top <kinesic desc="moves discs" iterated="n"/> N-minus-one discs <pause dur="0.4"/> these guys from the <pause dur="0.6"/> auxiliary pole <pause dur="2.0"/> to the destination <pause dur="2.3"/> okay and 
these <pause dur="0.4"/><kinesic desc="indicates point on transparency" iterated="n"/> green remarks here <pause dur="0.4"/> about which pole we want to use <pause dur="1.2"/> to do that <pause dur="0.8"/> is the <kinesic desc="indicates pole" iterated="n"/> spare pole that we will use each time round <pause dur="4.3"/> okay <pause dur="0.8"/> so the Towers of Hanoi <pause dur="0.9"/> is a actually a very simple problem <pause dur="2.0"/> but it gets progressively bigger each time round <pause dur="0.8"/> if we add another disc <pause dur="0.4"/> we double the size of the problem we double <pause dur="0.5"/> the number of steps that we need to <pause dur="0.5"/> take to make it work <pause dur="1.8"/><kinesic desc="changes transparency" iterated="y" dur="15"/> can i move this <pause dur="12.5"/> okay <pause dur="2.3"/> so how do we do that <pause dur="0.6"/> in Java <pause dur="6.7"/> how many people have found have looked at <pause dur="0.2"/> at least one program <pause dur="0.4"/> that i have made available online in my filestore <pause dur="1.6"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people haven't <pause dur="3.6"/><kinesic desc="put hands up" iterated="n" n="ss"/> okay if you want to look at this program it's in <pause dur="0.2"/> tilde-C-S-rat-slash-Java-slash-five-slash-Hanoi-dot-Java <pause dur="1.8"/><kinesic desc="reveals covered part of transparency" iterated="n"/> with a capital H <pause dur="6.2"/> and this <pause dur="1.1"/> slide <pause dur="3.2"/> is number forty <pause dur="0.7"/> this was given out with the methods <pause dur="0.3"/> slides <pause dur="14.4"/> okay in this program <pause dur="8.8"/> i've set <pause dur="0.2"/> N <pause dur="0.8"/> to 
be four and N just tells us <pause dur="0.6"/> how many discs we have <pause dur="1.2"/> to deal with <pause dur="0.8"/> so in this particular example we have <pause dur="1.1"/><kinesic desc="indicates discs" iterated="n"/> four discs <pause dur="2.6"/> and i've added a final keyword here because we could make that a constant if we wanted <pause dur="0.5"/> 'cause this value of N isn't going to change <pause dur="0.4"/> inside the program <pause dur="1.8"/> okay this value of N is going to be constant throughout the program so you could and it would be sensible in fact <pause dur="0.5"/> to put <pause dur="0.6"/> the final keyword <pause dur="0.3"/> at the beginning there <pause dur="3.4"/><kinesic desc="reveals covered part of transparency" iterated="n"/> okay and the main part of this program <pause dur="5.2"/> simply <pause dur="1.7"/> prints out a heading <pause dur="0.8"/> Towers of Hanoi for <pause dur="0.8"/> four discs <pause dur="1.1"/> and then calls <pause dur="1.2"/> a method <pause dur="7.2"/><event desc="prop breaks" iterated="n"/> it's a very old prop <pause dur="5.0"/><kinesic desc="turns on overhead projector showing transparency" iterated="n"/> then calls a method <pause dur="0.2"/> move <pause dur="0.3"/> to move a disc from one pole <pause dur="1.3"/> to another <pause dur="1.7"/> okay and this is the output <pause dur="0.5"/> this slide over here <pause dur="3.3"/> okay so <pause dur="2.8"/><kinesic desc="reveals covered part of transparency" iterated="n"/> in this program <pause dur="2.5"/> which you have <pause dur="1.2"/><kinesic desc="indicates point on transparency" iterated="n"/> this method move is the key thing that we <pause dur="0.2"/> are going to use <pause dur="1.0"/> okay <pause dur="0.3"/> and just as we 
defined the problem <pause dur="0.6"/> in terms of a <pause dur="0.6"/> solution <pause dur="0.3"/> the solution to the problem in terms of the solution to an easier problem <pause dur="0.3"/> so the solution to four <pause dur="0.5"/> was defined in terms of the solution to three <pause dur="0.5"/> we will <pause dur="0.5"/> define a <pause dur="0.3"/> method in terms of # <pause dur="2.6"/><kinesic desc="put hand up" iterated="n" n="sm0721"/> the method itself <pause dur="0.3"/> is that is that a hand </u><u who="sm0721" trans="latching"> yeah <pause dur="0.6"/> can you refer to a method before you declare it </u><pause dur="0.4"/> <u who="nm0718" trans="pause"> can i </u><pause dur="0.4"/> <u who="sm0721" trans="pause"> refer to a method before you declare it </u><pause dur="1.1"/> <u who="nm0718" trans="pause"> yes <pause dur="1.3"/> yes you can call a method before it's declared <pause dur="0.2"/> you have to typically <pause dur="1.7"/> 'cause you wouldn't be able to use any methods <pause dur="0.7"/> # <pause dur="0.6"/> unless they were <pause dur="1.0"/> declared afterwards you couldn't use a method in the main method <pause dur="2.6"/> so all the examples that you've seen so far probably have methods that are <pause dur="0.8"/> used before they're declared <pause dur="3.1"/> okay so we've got <pause dur="0.2"/> simply the main method up here which is the main bit of the program <pause dur="0.4"/> and down here we have the <pause dur="0.3"/> move method that we're going to use to do all of the work of this particular <pause dur="0.3"/> program to solve the Towers of Hanoi problem <pause dur="0.7"/> and <pause dur="1.3"/><kinesic desc="indicates point on transparency" iterated="n"/> this 
method move <pause dur="1.6"/> it's a static method 'cause it's a <pause dur="1.7"/> class method there is no particular object that we're associating with it <pause dur="1.5"/> and it takes <pause dur="1.3"/> one two three four parameters four arguments <pause dur="0.3"/> the first is <pause dur="0.4"/> N <pause dur="0.5"/> which tells us how many discs we want to move <pause dur="1.6"/> okay <pause dur="0.3"/> in the first <pause dur="0.9"/> the first time round we use this the first time we call this thing we've got four <pause dur="0.6"/> discs so N is four <pause dur="0.8"/> and then it takes <pause dur="0.6"/> a letter a character <pause dur="0.6"/> referring to the source the auxiliary <pause dur="0.4"/> and the destination <pause dur="0.4"/> poles <pause dur="0.2"/> which i've called A B and C <pause dur="1.2"/> okay so when we call this first time round N is four <pause dur="0.6"/> source is A <pause dur="1.6"/> auxiliary is B <pause dur="0.5"/> and destination is C <pause dur="2.4"/> okay <pause dur="1.6"/> and trivially <pause dur="0.8"/> we know the answer when N is one <pause dur="0.5"/> if we've got one disc <pause dur="1.1"/> we can move it directly <pause dur="1.2"/> okay everyone can do that <pause dur="1.0"/> 'cause you laughed when i asked if you could <pause dur="1.0"/> and we can write that out directly if N equals one <pause dur="1.1"/> then simply print out <pause dur="0.4"/> move disc <pause dur="1.1"/> and N refers to the the number of the disc <pause dur="0.4"/> which is one <pause dur="0.6"/> from the source to the destination <pause dur="0.4"/> directly <pause dur="0.5"/> okay <pause dur="0.4"/> and <pause dur="0.2"/> because source and 
destination are variables referring to <pause dur="1.3"/> which have the particular <pause dur="0.3"/> characters that we've got <pause dur="2.6"/> it's fairly straightforward to do that <pause dur="1.3"/> okay so if we just had one disc <pause dur="0.2"/> if N was one inside this program <pause dur="0.4"/> we would just simply have one <pause dur="0.3"/> A B C <pause dur="0.5"/> source would be A destination would be B and we'd simply move <pause dur="0.6"/> disc one from A to B <pause dur="0.2"/> sorry from A to C <pause dur="0.5"/> <unclear>right</unclear> <pause dur="2.2"/> but if we haven't got <pause dur="0.3"/> one disc if we've got more than one discs <pause dur="0.6"/> then it becomes a little more difficult <pause dur="0.7"/> okay <pause dur="0.4"/> but using recursion <pause dur="1.2"/> all we need to do <pause dur="0.2"/> is write down the form of the solution <pause dur="1.3"/> okay <pause dur="0.2"/> and that's pretty much all we need to do <pause dur="0.8"/> we simply need to move <pause dur="0.3"/> N-minus-one discs <pause dur="0.5"/> so in the case where we had <pause dur="2.1"/><kinesic desc="holds up prop" iterated="n"/> if i can reconstruct this particular thing <pause dur="4.1"/> in the case where we had <trunc>f</trunc> <pause dur="0.7"/> four discs <pause dur="0.9"/><kinesic desc="moves discs" iterated="n"/> the trick is to move three discs <pause dur="0.4"/> to the middle pole <pause dur="0.9"/> which is what <pause dur="0.2"/><kinesic desc="indicates point on transparency" iterated="n"/> this line says <pause dur="0.4"/> move three discs N-minus-one <pause dur="0.5"/> from the source <pause dur="0.4"/> to the auxiliary <pause dur="0.6"/> using the destination <pause dur="1.3"/> okay <pause dur="0.6"/> we've got source <pause dur="0.5"/> auxiliary destination <pause dur="0.6"/> and this <pause dur="0.7"/><kinesic desc="indicates point on transparency" iterated="n"/> says <pause dur="0.2"/> move from here <pause dur="0.3"/><kinesic desc="indicates point on transparency" iterated="n"/> to 
here <pause dur="0.5"/><kinesic desc="indicates point on transparency" iterated="n"/> using this <pause dur="1.9"/><kinesic desc="indicates point on transparency" iterated="n"/> okay <pause dur="0.3"/> and that's <pause dur="0.5"/> all we're saying there <pause dur="3.8"/> then <pause dur="0.8"/> write out <pause dur="0.8"/> the solution to <pause dur="0.4"/> moving one disc <pause dur="0.2"/> from <pause dur="0.7"/> the source to the destination <pause dur="1.3"/><kinesic desc="moves disc" iterated="n"/> okay <pause dur="0.3"/> which is <pause dur="0.3"/> disc N disc four in this case <pause dur="1.9"/> that's the bit in the middle <pause dur="0.6"/> and then we simply solve the problem <pause dur="0.3"/> to move <pause dur="0.2"/> three discs <pause dur="1.2"/> from here <pause dur="0.5"/><kinesic desc="moves disc" iterated="n"/> from the auxiliary <pause dur="0.7"/> to the destination <pause dur="0.5"/> using the source <pause dur="1.9"/> okay <pause dur="0.4"/> that's all that this says <pause dur="3.6"/> but that's easy we know <trunc>t</trunc> how we can do that 'cause we simply know <pause dur="0.2"/> we simply need to say <pause dur="0.4"/> how do we work out <pause dur="0.8"/> the solution with <pause dur="0.8"/> three discs <pause dur="0.4"/> that's the only thing we need to work out to make this <pause dur="0.2"/> complete solution work <pause dur="0.8"/> and when we hit move again the second time <pause dur="1.7"/> all we do is <pause dur="1.0"/> call this <pause dur="0.5"/><kinesic desc="indicates point on transparency" iterated="n"/> method <pause dur="1.0"/> with <pause dur="0.4"/><kinesic desc="indicates point on transparency" iterated="n"/> this N <pause dur="0.2"/> being set to be <pause dur="0.6"/> the new N-minus-one <pause dur="0.6"/> so this is now the new time we call the next time we call move <pause dur="0.5"/> N now has the value of N-minus-one <pause dur="0.3"/> which is three <pause dur="1.0"/> the source <pause dur="0.7"/> gets assigned to <pause dur="0.5"/><kinesic desc="indicates point on transparency" iterated="n"/> 
this source the destination gets exsigned gets assigned to the auxiliary <pause dur="0.8"/> and the auxiliary <pause dur="0.3"/> gets assigned to the new destination <pause dur="0.6"/> so when we were moving <pause dur="0.5"/><kinesic desc="moves discs" iterated="n"/> three discs <pause dur="0.8"/> at the beginning <pause dur="0.9"/> if i can just swap it around <pause dur="1.3"/><kinesic desc="turns prop around" iterated="n"/> okay we wanted to move <pause dur="0.4"/> all of these to here <pause dur="0.5"/><kinesic desc="indicates pole" iterated="n"/> and the way we did that was by moving these three <kinesic desc="indicates discs" iterated="n"/> the top three <pause dur="0.5"/> to the middle pole <pause dur="0.8"/><kinesic desc="indicates pole" iterated="n"/> we simply <pause dur="0.3"/> changed the order of the arguments changed the order of the poles so that <pause dur="0.7"/> when we call it again we have to find the solution to moving <pause dur="1.1"/> from the source <pause dur="0.3"/> to the auxiliary <pause dur="1.2"/> okay <pause dur="0.8"/><kinesic desc="moves discs" iterated="n"/> these three moving to here <pause dur="2.3"/> and if we <pause dur="0.2"/> make those assignments <pause dur="1.9"/> we can <pause dur="0.2"/> check to see if it's one disc that we're moving and it's not it's three <pause dur="2.5"/> so we <pause dur="0.5"/> simply need to do that in terms of <pause dur="0.5"/> moving N-minus-one discs <pause dur="1.3"/> which is two discs <pause dur="2.2"/><kinesic desc="moves discs" iterated="n"/> from the <pause dur="0.5"/> source <pause dur="1.3"/> to the auxiliary <pause dur="0.5"/> using the <pause dur="0.3"/> destination <pause dur="0.7"/> well <pause dur="0.6"/> the new auxiliary <pause dur="0.3"/> is <pause dur="1.6"/><kinesic desc="indicates pole" iterated="n"/> 
this one <pause dur="1.3"/> and the new destination is <kinesic desc="indicates pole" iterated="n"/> this one <pause dur="0.3"/> sorry the new auxiliary is <kinesic desc="indicates pole" iterated="n"/> this one and the <kinesic desc="indicates pole" iterated="n"/> new destination is this one <pause dur="0.4"/> so we work out the problem to <trunc>s</trunc> <pause dur="0.2"/> to moving two across <pause dur="1.2"/> then we can move <pause dur="0.7"/> we can write the solution to moving one directly <pause dur="0.4"/> and then we can work out <pause dur="0.6"/> the solution to moving <pause dur="0.2"/> the last <pause dur="1.6"/> two across <pause dur="1.2"/> again <pause dur="0.4"/> okay <pause dur="0.2"/> and eventually we'll get down to a point where we're only working this out in terms of moving one disc at a time <pause dur="0.8"/> when we're moving one disc at a time <pause dur="0.9"/> we have the solution directly <pause dur="1.7"/><kinesic desc="reveals covered part of transparency" iterated="n"/> so <pause dur="2.6"/> let's have a look at how that works <pause dur="7.1"/> can you see this at the back <pause dur="3.0"/> okay <pause dur="1.0"/> first thing we do is to move <pause dur="1.0"/> disc one from A to B <pause dur="0.7"/> so it's <pause dur="1.2"/><kinesic desc="moves discs" iterated="y" dur="23"/> here to here <pause dur="0.3"/> disc two from A to C <pause dur="1.4"/> disc three from A to B <pause dur="1.3"/> sorry <pause dur="0.2"/> disc one from B to C <pause dur="4.3"/> disc three 
from A to B <pause dur="0.3"/> and so on <pause dur="0.5"/> okay it should be clear that <pause dur="2.2"/> this <pause dur="0.4"/> solution is correct disc one from C to A <pause dur="0.7"/> disc two from C to B <pause dur="1.5"/> okay <pause dur="0.9"/> disc <pause dur="0.6"/> one <pause dur="2.2"/> from A <pause dur="0.3"/> to <pause dur="0.7"/> B <pause dur="0.6"/> that's moved three across <pause dur="1.4"/> okay <pause dur="1.1"/> this chunk of the solution <pause dur="0.7"/> simply moves three discs <pause dur="1.6"/> across <pause dur="1.2"/> from <pause dur="0.4"/><kinesic desc="indicates pole" iterated="n"/> the source <pause dur="0.2"/> to the auxiliary <pause dur="0.2"/><kinesic desc="indicates pole" iterated="n"/> using the destination <pause dur="0.8"/><kinesic desc="indicates pole" iterated="n"/> but if we examine that in more detail <pause dur="0.5"/><kinesic desc="reveals covered part of transparency" iterated="n"/> we would have to make a call <pause dur="1.2"/> another move to move <pause dur="0.2"/> N-minus-one discs two discs <pause dur="2.4"/> from A to C using B <pause dur="0.6"/> okay and <kinesic desc="indicates screen" iterated="n"/> that's the solution that we've got up there <pause dur="0.6"/> if we change the N here <kinesic desc="indicates point on transparency" iterated="n"/> at the beginning of our program to be <pause dur="1.1"/> two <pause dur="0.4"/> we would just get a trace of three moves <pause dur="1.1"/> okay if it was two we would just simply <pause dur="1.1"/> move N-minus-one discs <pause dur="2.8"/> which would be one <pause dur="1.5"/> move the one in the middle <pause dur="0.5"/> and then move <pause dur="0.7"/> N-minus-one discs again which would again be the one <pause dur="2.3"/> okay <pause dur="0.4"/> so <pause dur="0.2"/> the solution to two discs is simply three statements <pause dur="0.8"/> then we would move the one in the middle <pause dur="2.0"/><kinesic desc="moves discs" iterated="y" dur="8"/> 
okay <pause dur="1.4"/> so it would be moving two to here <pause dur="1.1"/> moving the one in the middle <pause dur="0.5"/> and then moving two back again <pause dur="1.4"/> okay and you can see the structure <pause dur="1.8"/><kinesic desc="reveals covered part of transparency" iterated="n"/> of this as we build it up <pause dur="0.9"/> is <pause dur="1.2"/> there is a solution that is defined in terms of <pause dur="0.8"/> the solution to two smaller problems plus a direct move in the middle <pause dur="1.7"/> so all of this <pause dur="0.3"/><kinesic desc="indicates transparency" iterated="n"/> is the solution <pause dur="2.4"/> to four discs <pause dur="1.5"/> the green line <pause dur="0.5"/> indicates the solution <pause dur="0.4"/> to <pause dur="0.4"/> three discs <pause dur="1.2"/> the red line indicates the solution to two discs <pause dur="1.2"/> okay <pause dur="0.3"/> and if we look at the solution to three discs in terms of the solution to two discs <pause dur="0.3"/> it's simply <pause dur="0.3"/> the solution to two discs plus a direct move <pause dur="1.0"/> plus the solution to two discs again <pause dur="0.4"/> if we look at the solution to four discs in terms of the solution to three discs it's <pause dur="1.3"/> the solution to three plus a direct move plus the solution to three again <pause dur="2.5"/> okay and that's all there is <pause dur="0.2"/> this program <pause dur="0.3"/> 
generates that output and it's probably one of the simplest programs you'll find to do something quite complicated </u><gap reason="break in recording" extent="uncertain"/> <u who="nm0718" trans="pause"> <kinesic desc="changes transparency" iterated="y" dur="7"/> another example <pause dur="9.4"/> and this example is in tilde-C-S-rat-slash-Java-slash-five-<pause dur="0.7"/>slash-fact-one-dot-Java <pause dur="0.3"/> and also fact-two-dot-Java <pause dur="0.7"/> how many people <pause dur="0.3"/> don't know what a factorial is <pause dur="2.5"/><kinesic desc="put hands up" iterated="n" n="ss"/> okay <pause dur="0.9"/> factorial <pause dur="1.5"/> is simply <pause dur="1.8"/> a very simple mathematical thing <pause dur="3.4"/><kinesic desc="writes on transparency" iterated="y" dur="9"/> four-factorial is simply <pause dur="0.7"/> four <pause dur="0.2"/> times three <pause dur="0.3"/> times two <pause dur="0.4"/> times one <pause dur="1.2"/><kinesic desc="writes on transparency" iterated="y" dur="6"/> five-factorial <pause dur="0.4"/> is simply five times four times three <pause dur="0.3"/> times two <pause dur="0.2"/> times one <pause dur="0.7"/> that's all factorial is <pause dur="7.8"/><kinesic desc="reveals covered part of transparency" iterated="n"/> okay <pause dur="0.3"/> so <pause dur="0.2"/> iteratively <pause dur="0.5"/> and iterative is just <pause dur="0.3"/> looping around <pause dur="2.3"/> in circles iteratively the solution to N-factorial is simply <pause dur="0.3"/> N times N-minus-one times N-minus-two <pause dur="0.4"/> all the way through to one <pause dur="0.8"/> so the solution to six-factorial is <pause dur="0.5"/> six times five times four times three times two times one <pause dur="0.3"/> and we could loop round <pause dur="1.5"/> in a while loop 
or a for loop simply multiplying numbers together <pause dur="0.4"/> generating that kind of <pause dur="0.7"/> result <pause dur="1.6"/> we know that <pause dur="0.5"/> N-factorial is equal to one <pause dur="0.2"/> when <pause dur="0.4"/> N is zero <pause dur="0.4"/> okay we're given that <pause dur="0.2"/> we know that <pause dur="1.4"/> and if we wanted to write <pause dur="0.8"/> a method <pause dur="0.7"/> to do that <pause dur="1.7"/> we could simply write this <pause dur="0.8"/><kinesic desc="indicates point on transparency" iterated="n"/> factorial method <pause dur="0.6"/> which starts out by setting <pause dur="0.4"/> F <pause dur="1.4"/> an integer F to be one <pause dur="1.0"/> and then have a for loop looping from one <pause dur="1.0"/> to N <pause dur="0.7"/> so <pause dur="0.9"/> I is set to be one initially <pause dur="0.4"/> we loop round while I is less than or equal to N <pause dur="0.3"/> and each time round the loop we add one to I <pause dur="0.9"/> and inside that loop we simply multiply <pause dur="1.9"/> F <pause dur="0.2"/> by I <pause dur="1.9"/><kinesic desc="changes transparency" iterated="y" dur="8"/> okay so if we have a look at <pause dur="0.5"/> how that would work <pause dur="6.1"/> okay <pause dur="3.2"/> first of all <pause dur="2.8"/> when we call this method <pause dur="0.3"/> N is five <pause dur="3.2"/> which is <pause dur="0.5"/> what's given to us as a parameter <pause dur="0.5"/> then we set F to be one <pause dur="0.8"/> and then we loop round with I taking values one two three four and five <pause dur="0.6"/> and the first time through the loop we simply multiply <pause dur="0.5"/> F by I <pause dur="0.4"/> and put the result in F <pause dur="0.2"/> so <pause dur="0.4"/> it's <pause dur="0.2"/> one times one which is one <pause dur="1.9"/> the second time round I is two <pause dur="0.5"/> so 
we get <pause dur="0.6"/> one times two <pause dur="1.1"/> which is two <pause dur="1.3"/> the third time round I is three so we take the new <pause dur="0.3"/> value of F which is two multiply it by three <pause dur="0.8"/> and we get six <pause dur="1.1"/> the next time round I is four <pause dur="0.4"/> multiply that by six we get twenty-four <pause dur="0.4"/> the next time round I is five <pause dur="0.3"/> multiply that by twenty-four <pause dur="0.4"/> and we get a hundred-and-twenty <pause dur="0.7"/> okay and at that point we find that <pause dur="0.8"/> I is no longer less than or equal to N and so we stop this <pause dur="0.5"/> and we can return the value F at the end of this loop <pause dur="1.0"/> as the result <pause dur="0.2"/> of calculating factorial <pause dur="0.6"/> okay so that's just a loop that will loop round <pause dur="0.3"/> multiplying things together <pause dur="0.9"/><kinesic desc="reveals covered part of transparency" iterated="n"/> now <pause dur="0.8"/> we can also do that recursively <pause dur="0.9"/> recursively where we define the solution to one thing in terms of the solution to a <pause dur="0.3"/> simpler problem <pause dur="0.8"/> okay <pause dur="0.3"/> so we can say that N-factorial <pause dur="1.4"/> is simply <pause dur="0.3"/> N times N-minus-one-factorial <pause dur="1.1"/> so six-factorial is simply <pause dur="0.9"/> six times five-factorial <pause dur="0.5"/> five-factorial is simply five times four-factorial <pause dur="0.6"/> it doesn't matter <pause dur="0.2"/> how we get those results <pause dur="0.2"/> we can define it like that <pause dur="0.7"/> and <pause dur="1.4"/> we can 
write a solution directly in those terms <pause dur="0.2"/> as long as we have a base case as long as there is something <pause dur="1.3"/> that we understand how to solve directly <pause dur="0.9"/> okay <pause dur="1.0"/> so in recursion you have to have <pause dur="0.8"/> a general case of how you define <pause dur="0.5"/> a more complex problem in terms of a simpler problem <pause dur="2.2"/> and as well as that <pause dur="0.5"/> some simple problem that you can solve directly <pause dur="0.6"/> and we know that <pause dur="1.2"/><kinesic desc="reveals covered part of transparency" iterated="n"/> N-factorial is one when N is equal to zero <pause dur="1.9"/> and so with a recursive <pause dur="1.0"/> method <pause dur="1.0"/> you have the same heading <pause dur="2.0"/> we simply check at the beginning to see if N is greater than zero <pause dur="0.6"/> if it is <pause dur="1.4"/> we have to do some calculations <pause dur="0.4"/> if it's not we'll return the value one directly <pause dur="1.0"/> okay <pause dur="0.4"/> but if it is greater than zero we simply return the value of N <pause dur="0.4"/> times <pause dur="0.3"/> the value that we get by applying this factorial method <pause dur="0.3"/> to N-minus-one <pause dur="1.2"/> how does that work <pause dur="3.9"/><kinesic desc="reveals covered part of transparency" iterated="n"/> okay so if N is <pause dur="0.8"/> six we want to return six times the result of doing factorial on five <pause dur="0.9"/> okay and this <pause dur="0.8"/><kinesic desc="indicates transparency" iterated="n"/> shows how the recursive method works <pause dur="2.1"/> 
with five <pause dur="1.1"/> as an argument <pause dur="1.6"/> okay so what we do is we start out by saying <pause dur="0.4"/> N is five <pause dur="1.0"/> is N greater than zero <pause dur="0.2"/> yes <pause dur="0.4"/> so we return <pause dur="0.4"/> five times factorial of four <pause dur="1.1"/> okay but we don't know what factorial of four is yet <pause dur="1.0"/> and at the point at which we hit factorial of four there <pause dur="0.4"/><kinesic desc="indicates point on transparency" iterated="n"/> we simply make another call <pause dur="0.3"/> to this method <pause dur="0.7"/> now with N being four <pause dur="0.4"/> and we do the same thing again <pause dur="0.7"/> okay so we <trunc>maintai</trunc> we <pause dur="0.9"/> we have to maintain these results bit by bit <pause dur="0.7"/> okay we come down <pause dur="0.5"/><kinesic desc="indicates point on transparency" iterated="n"/> here <pause dur="0.6"/> before we can <pause dur="0.3"/> get the results to use back in these calculations <pause dur="1.5"/> when N is four <pause dur="0.5"/> we return four times factorial of three <pause dur="0.4"/> and we have to go round again <pause dur="0.3"/> when N is three we return <pause dur="0.8"/> three times <pause dur="0.5"/> factorial of two <pause dur="1.8"/> when N is two we return two times <pause dur="0.4"/> factorial of one <pause dur="4.8"/> and at that point <pause dur="1.4"/> when we come round again <pause dur="1.7"/> we do it once more <pause dur="0.4"/> one times factorial of zero <pause dur="0.6"/> and then <pause dur="0.3"/> this is no longer true <pause dur="1.3"/> okay so at the point where we've got zero <pause dur="0.8"/> in the sixth call <pause dur="0.8"/> to this thing <pause dur="1.6"/> we've got a value for one <pause dur="0.5"/> so we've got a value for factorial of zero <pause dur="0.3"/> which 
we can use <pause dur="0.8"/> when we're trying to work out <pause dur="1.8"/> factorial of one <pause dur="0.7"/> factorial of two <pause dur="0.3"/> factorial of three and so on okay <pause dur="0.6"/> we get a value of factorial-zero which is one <pause dur="0.3"/> we pass it back up to the previous calculation <pause dur="0.7"/> so we now have a <trunc>fac</trunc> <pause dur="0.3"/> we now have a value of <pause dur="0.7"/> factorial of one which we can use in the next <pause dur="0.5"/> calculation <pause dur="1.2"/> we have a value of factorial of two which we can use in the previous one and so on so it <pause dur="0.6"/> keeps going back up so we have to go <pause dur="0.6"/> all the way down <pause dur="0.3"/> to the bottom <pause dur="0.8"/> before we can use those values that we've worked out <pause dur="1.2"/><kinesic desc="indicates point on transparency" iterated="n"/> substituting them back into these <pause dur="1.6"/> calculations <pause dur="1.2"/> to get out the result at the top <pause dur="3.2"/> how many people understand that <pause dur="1.7"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people don't <pause dur="2.5"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people didn't put their hands up <pause dur="2.9"/><kinesic desc="put hands up" iterated="n" n="ss"/> yeah <vocal desc="laugh" iterated="n"/><pause dur="3.0"/> always ceases <pause dur="1.6"/> it never ceases <pause dur="1.5"/> to amaze me <pause dur="1.3"/> you know i'm going to ask you a question <pause dur="1.1"/> you know i'm going to ask you at the end how many people didn't put their hand up <pause dur="1.1"/> why <pause dur="0.5"/> you don't <pause dur="0.3"/> beats me <pause dur="2.7"/> okay <pause dur="0.4"/> there's 
something very important to note about this <pause dur="0.5"/><kinesic desc="put hand up" iterated="n" n="sm0722"/> yeah </u><pause dur="0.7"/> <u who="sm0722" trans="pause"> is recursion more efficient than <gap reason="inaudible" extent="1 sec"/> in terms of speed <gap reason="inaudible" extent="1 sec"/> </u><u who="nm0718" trans="latching"> we'll get on to that <pause dur="1.3"/> it's a very good question the question is is recursion more efficient <pause dur="1.0"/> and the answer is no but we'll get on to why <pause dur="3.8"/><vocal desc="laughter" iterated="y" n="ss" dur="3"/> the problem with this is that <pause dur="0.9"/> we have to maintain all these values we don't know what the solution to factorial-six is <pause dur="0.7"/> until we've worked out factorial-five factorial-four factorial-three factorial-two factorial-one <pause dur="0.4"/> and so on <pause dur="0.4"/> and we have to maintain all of these values <pause dur="0.4"/> all at the same time until we find <pause dur="0.6"/> the value of factorial-zero which we can use to find factorial-one <pause dur="0.4"/> and then to find factorial-two and so on <pause dur="0.3"/> so we have to maintain <pause dur="0.5"/> six sets <pause dur="0.7"/> of <pause dur="1.8"/> all the variables that are needed to work this out <pause dur="1.4"/> okay so we have to maintain six sets of that <pause dur="0.5"/> whereas in the previous example the <pause dur="0.4"/> iterative solution <pause dur="0.3"/> we only have to maintain five sets of things <pause dur="1.5"/> sorry we only <trunc>m</trunc> have to maintain one set of <pause dur="0.4"/> # 
variables <pause dur="0.9"/> okay so <pause dur="0.4"/> we need <pause dur="0.3"/> much more memory <pause dur="1.1"/> # <pause dur="0.3"/> with six <pause dur="0.7"/> it's not a problem with five we we work these things out on on five <pause dur="1.1"/> with N being five it's not a big deal <pause dur="0.2"/> because it's only about thirty variables <pause dur="1.4"/> okay <pause dur="0.4"/> but when we start using <pause dur="0.4"/> much larger numbers <pause dur="1.2"/> okay then it becomes prohibitive <pause dur="1.4"/> okay so recursion which is very very powerful <pause dur="0.4"/> can take up a lot of space <pause dur="0.3"/> and also <pause dur="0.2"/> it can take up a lot of time to do it <pause dur="0.2"/> can be not very powerful because of that <pause dur="0.5"/> # we're going through all of these <pause dur="0.8"/> <trunc>iterat</trunc> recursive calls <pause dur="2.5"/> but the key thing to note is that <pause dur="2.9"/> it's much nicer to write down <pause dur="0.4"/> than the other solution the other solution required a for loop we had to work various things out <pause dur="0.6"/><kinesic desc="indicates point on transparency" iterated="n"/> this simply states what the problem is <pause dur="0.5"/> it simply states that if N is greater than zero <pause dur="0.6"/> you got to work out N times factorial of N-minus-one <pause dur="0.4"/> otherwise you know the answer directly <pause dur="1.3"/> so it's much <pause dur="0.4"/> nicer much neater much simpler <pause dur="0.4"/> to do <pause dur="1.6"/> than <kinesic desc="indicates transparency" iterated="n"/> this one <pause dur="3.8"/><kinesic desc="changes transparency" iterated="y" dur="7"/> okay i've got 
another example <pause dur="0.9"/> you don't have <pause dur="3.9"/> could someone tell me what these are <pause dur="2.9"/> # <pause dur="2.8"/> how many people know what these are <pause dur="2.3"/><kinesic desc="put hands up" iterated="n" n="ss"/> okay how many people don't <pause dur="1.4"/><kinesic desc="put hands up" iterated="n" n="ss"/> they're Fibonacci numbers <pause dur="1.6"/> Fibonacci numbers are simply <pause dur="9.7"/> Fibonacci numbers are simply numbers that are defined as the sum of the previous two numbers <pause dur="0.6"/> so if we start with zero and one <pause dur="0.4"/> then the next one is <pause dur="0.4"/> the sum of one and zero which is one the next one is <pause dur="0.8"/> the sum of one and one which is two the next one is the sum of two and one which is three the next one is the sum sum of <pause dur="0.5"/> three and two which is five and so on <pause dur="0.9"/> okay Fibonacci numbers <pause dur="1.4"/><kinesic desc="reveals covered part of transparency" iterated="n"/> very simple <pause dur="0.8"/> and this is a <pause dur="0.5"/> again something that's <pause dur="0.2"/> recursive <pause dur="0.7"/> we have to know the <pause dur="0.5"/> previous two numbers to be able to work out the next one <pause dur="1.3"/> you don't have this <pause dur="0.9"/> if you're looking through your <pause dur="0.8"/> through your <pause dur="0.2"/> notes <pause dur="0.2"/> you don't have this <pause dur="3.8"/> but it's 
pretty much the same as the things we've seen before it's very simple <pause dur="1.1"/> here's the whole program <pause dur="0.3"/> rather than just the method <pause dur="0.6"/> i've just got a heading <pause dur="0.7"/> saying sixth Fibonacci number is <pause dur="0.3"/> and then a call to the <pause dur="0.3"/><kinesic desc="reveals covered part of transparency" iterated="n"/> Fibonacci method that i've got below <pause dur="1.3"/> okay <pause dur="6.9"/> and this Fibonacci method simply takes an integer N <pause dur="2.1"/> and it <pause dur="0.8"/> has three possible cases one is that <pause dur="0.5"/> N is zero <pause dur="1.0"/> if N is zero then we return zero <pause dur="1.3"/> otherwise if N is one we return one <pause dur="0.5"/> 'cause we have to have two numbers to start with <pause dur="0.7"/> zero and one we're going to start out with at the beginning <pause dur="1.0"/> base case <pause dur="0.6"/> and if not <pause dur="0.6"/> if we're <pause dur="0.2"/> anywhere up <pause dur="1.0"/> further up <pause dur="1.2"/> then we simply return <pause dur="1.5"/> the value that we get by calling the Fibonacci method on <pause dur="0.4"/> N-minus-one added to the value that we get by calling the Fibonacci method on <pause dur="1.8"/> N-minus-<pause dur="0.9"/>two did i say N-minus-two before <pause dur="1.5"/> N-minus-one and N-minus-two <pause dur="0.3"/> okay so we simply <pause dur="1.5"/> work through that <pause dur="0.4"/> and that's all we have to do and that's simply <pause dur="0.6"/> if you look at it it's simply a statement of 
the problem rather than doing <pause dur="0.4"/> anything complicated anything sophisticated in terms of <pause dur="1.8"/> trying to work these things out <pause dur="0.4"/> simply states <pause dur="0.2"/> how we define Fibonacci numbers <pause dur="0.4"/> and Java <pause dur="0.3"/> will solve that problem for you <pause dur="0.8"/> okay it will go through these <trunc>reci</trunc> recursive calls <pause dur="0.4"/> trying to work it all out <pause dur="2.3"/> and again this program is in <trunc>tilde-C-S-rat-slash-five-slash-jav</trunc> <pause dur="0.4"/> tilde-C-S-rat-slash-Java-slash-five-<pause dur="0.8"/>#-<pause dur="0.7"/>fibo-<pause dur="0.2"/>dot-Java <pause dur="3.0"/> are there any questions <pause dur="4.5"/> how many people think they understand recursion <pause dur="1.5"/><kinesic desc="put hands up" iterated="n" n="ss"/> how many people don't <pause dur="2.3"/> okay <pause dur="0.5"/> good <pause dur="0.6"/> let's write a little note <pause dur="2.0"/><kinesic desc="changes transparency" iterated="y" dur="3"/> about when we would use this <pause dur="8.4"/><kinesic desc="writes on transparency" iterated="y" dur="5"/> can you see that at the back <pause dur="4.0"/><kinesic desc="writes on transparency" iterated="y" dur="10"/> when should we use recursion and when should we use iteration <pause dur="16.0"/> okay because we can always <pause dur="0.4"/> find an iterative way <pause dur="1.7"/> to solve a recursive problem <pause dur="2.5"/> okay we can solve problems <pause dur="0.3"/> either way <kinesic desc="writes on transparency" iterated="y" dur="43"/> so the question is why bother to use recursion <pause dur="0.7"/> and the answer is <pause dur="1.7"/> when it's most natural <pause dur="5.1"/> and easily expressed <pause dur="32.2"/> we'd use 
iteration when efficiency matters <pause dur="0.7"/> okay if we don't have enough <pause dur="1.3"/> memory <pause dur="2.0"/> or if the solution is straightforward <pause dur="0.5"/> iteratively <pause dur="0.4"/> then we would use <pause dur="0.3"/> iteration <pause dur="0.7"/> but recursion is most <pause dur="0.6"/> useful when it's <pause dur="1.2"/> very easy to write it down <pause dur="1.3"/> okay so when it's most natural <pause dur="0.4"/> and easily expressed <pause dur="4.7"/><vocal desc="clears throat" iterated="n"/><pause dur="1.0"/> in every test every second test <pause dur="0.7"/> in the last five years there has been a question on <pause dur="0.3"/> recursion <pause dur="1.3"/> every single one <pause dur="4.8"/> are there any questions <pause dur="3.5"/> okay can i move this off <pause dur="5.5"/> we got one <pause dur="0.3"/> or two things to say about the assignment before we finish today <pause dur="11.8"/> the first <pause dur="1.9"/> is that you will have a new submission sheet <pause dur="2.7"/><kinesic desc="holds up sheet" iterated="n"/> it'll be it's a yellow one but it's new <pause dur="0.5"/> and that's because <pause dur="1.6"/> unless you are a student who is not based in Computer Science <pause dur="1.4"/> you will have shortly in your pigeonholes <kinesic desc="holds up sheet" iterated="n"/> some bar codes <pause dur="1.3"/> okay <pause dur="0.4"/> a sheet of <trunc>s</trunc> stickers with bar codes on <pause dur="0.4"/> identifying you <pause dur="1.2"/> and what you have to do <pause dur="1.0"/> instructions are given to you but what you have to do is to take <pause dur="0.4"/> a bar 
code <pause dur="2.3"/><kinesic desc="holds up bar code" iterated="n"/> and <pause dur="0.3"/> fold up the bit of paper where it says <pause dur="0.3"/> fold line <pause dur="4.1"/><kinesic desc="folds paper" iterated="n"/> and then there's a box <pause dur="1.6"/><kinesic desc="indicates point on sheet" iterated="n"/> which will be partially obscured <pause dur="1.0"/> take your bar code <pause dur="0.7"/> and stick it <pause dur="2.6"/><kinesic desc="sticks bar code on sheet" iterated="n"/> like that so that it holds the paper up <pause dur="2.6"/><kinesic desc="holds up sheet" iterated="n"/> that's what you do that means we can't see who you are <pause dur="1.2"/> it's all done anonymously <pause dur="0.9"/> but it'll be more efficient <pause dur="1.2"/> okay <pause dur="0.6"/> so do this if you are <pause dur="0.7"/> not based in Computer Science you will fill it in as normal <pause dur="0.5"/> and hand it in to the secretaries who will then <pause dur="1.1"/> anonymize it for you <pause dur="0.2"/> we will not be giving you <pause dur="2.5"/> bar codes </u><pause dur="1.9"/> <u who="sm0723" trans="pause"> <gap reason="inaudible" extent="1 sec"/></u><pause dur="0.7"/> <u who="nm0718" trans="pause"> sorry </u><pause dur="0.6"/> <u who="sm0723" trans="pause"> <gap reason="inaudible" extent="1 sec"/></u><pause dur="1.3"/> <u who="nm0718" trans="pause"> ah you'll have a pigeonhole they'll get them to you so it's C-S C-S-E <pause dur="1.4"/> C-M-S and C-B-S will all get bar codes and these are <trunc>s</trunc> distinct from the engineering codes <pause dur="1.1"/> that you <trunc>h</trunc> may already have <pause dur="7.2"/><kinesic desc="changes transparency" iterated="y" dur="5"/><event desc="noise from audience" iterated="y" dur="8"/> i haven't finished <pause dur="3.0"/> won't take long <pause dur="1.6"/> i don't mind not doing it <pause dur="3.5"/> there are three parts to assignment three <pause dur="1.5"/> you should do as many of them as possible <pause dur="0.6"/> the first part is worth seventy 
per cent <pause dur="0.4"/> for an extra fifteen per cent <pause dur="0.3"/> you should do the second part <pause dur="0.4"/> and for an extra <trunc>f</trunc> fifteen per cent on top of that <pause dur="0.8"/> you should do the third part <pause dur="0.2"/> that means that <pause dur="2.0"/> you can improve your mark continually so if you start early you have more chance of getting a hundred per cent <pause dur="1.4"/> okay you should be able to do all of them <pause dur="0.5"/> but i understand that for some of you it might be difficult <pause dur="1.8"/><kinesic desc="reveals covered part of transparency" iterated="n"/> you will have to use erase which we will cover in the next lecture <pause dur="2.5"/><kinesic desc="reveals covered part of transparency" iterated="n"/> the output that is given on the sheet the sample output <pause dur="0.4"/> and the output that you should be producing <pause dur="2.7"/> has no trailing spaces at the end of a line <pause dur="1.2"/> and the last line should be properly terminated that means that if you use <pause dur="0.6"/> system-dot-out-dot-<pause dur="0.6"/>print <pause dur="1.0"/> 
you should make sure that the last thing you do <pause dur="0.5"/> is system-dot-out-dot-print-ln <pause dur="0.9"/> to terminate your last line properly <pause dur="0.5"/> otherwise there will be problems <pause dur="2.6"/> note the new submission sheet <pause dur="1.4"/> and also <pause dur="0.4"/><kinesic desc="reveals covered part of transparency" iterated="n"/> the bar codes don't lose them <pause dur="0.8"/> if you lose them you will have to pay for more bar codes more bar code stickers <pause dur="1.7"/> okay <pause dur="1.9"/> the problem is in terms of matrices <pause dur="0.3"/> matrices are just collections of numbers <pause dur="1.2"/> it's not difficult if you haven't encountered matrices before <pause dur="1.3"/> there are hints <pause dur="1.9"/> on the back page <pause dur="0.8"/> and your seminar tutor will explain anything to you <pause dur="1.5"/> if you don't understand how to do it <pause dur="1.3"/> i will say a little bit more about this next time <pause dur="1.2"/> thank you
</u></body>
</text></TEI.2>