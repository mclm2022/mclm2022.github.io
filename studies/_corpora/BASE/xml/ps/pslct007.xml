<?xml version="1.0"?>
<!DOCTYPE TEI.2 SYSTEM "base.dtd">
<TEI.2><teiHeader>	
<fileDesc>
<titleStmt>
<title>unknown</title></titleStmt>
<publicationStmt><distributor>BASE and Oxford Text Archive</distributor>
<idno>pslct007</idno>	
<availability><p>The British Academic Spoken English (BASE) corpus was developed at the
Universities of Warwick and Reading, under the directorship of Hilary Nesi
(Centre for English Language Teacher Education, Warwick) and Paul Thompson
(Department of Applied Linguistics, Reading), with funding from BALEAP,
EURALEX, the British Academy and the Arts and Humanities Research Board. The
original recordings are held at the Universities of Warwick and Reading, and
at the Oxford Text Archive and may be consulted by bona fide researchers
upon written application to any of the holding bodies.
The BASE corpus is freely available to researchers who agree to the
following conditions:</p>
<p>1. The recordings and transcriptions should not be modified in any
way</p>
<p>2. The recordings and transcriptions should be used for research purposes
only; they should not be reproduced in teaching materials</p>
<p>3. The recordings and transcriptions should not be reproduced in full for
a wider audience/readership, although researchers are free to quote short
passages of text (up to 200 running words from any given speech event)</p>
<p>4. The corpus developers should be informed of all presentations or
publications arising from analysis of the corpus</p><p>
Researchers should acknowledge their use of the corpus using the following
form of words:
The recordings and transcriptions used in this study come from the British
Academic Spoken English (BASE) corpus, which was developed at the
Universities of Warwick and Reading under the directorship of Hilary Nesi
(Warwick) and Paul Thompson (Reading). Corpus development was assisted by
funding from the Universities of Warwick and Reading, BALEAP, EURALEX, the
British Academy and the Arts and Humanities Research Board. </p></availability>
</publicationStmt>
<sourceDesc>
<recordingStmt>
<recording dur="00:46:12" n="4880">
<date>25/01/2001</date><equipment><p>video</p></equipment>
<respStmt><name>BASE team</name>
</respStmt></recording></recordingStmt></sourceDesc></fileDesc>
<profileDesc>
<langUsage><language id="en">English</language>
</langUsage>
<particDesc>
<person id="nm0696" role="main speaker" n="n" sex="m"><p>nm0696, main speaker, non-student, male</p></person>
<person id="sm0697" role="participant" n="s" sex="m"><p>sm0697, participant, student, male</p></person>
<person id="sm0698" role="participant" n="s" sex="m"><p>sm0698, participant, student, male</p></person>
<person id="sm0699" role="participant" n="s" sex="m"><p>sm0699, participant, student, male</p></person>
<person id="sm0700" role="participant" n="s" sex="m"><p>sm0700, participant, student, male</p></person>
<person id="sm0701" role="participant" n="s" sex="m"><p>sm0701, participant, student, male</p></person>
<person id="sm0702" role="participant" n="s" sex="m"><p>sm0702, participant, student, male</p></person>
<person id="su0703" role="participant" n="s" sex="u"><p>su0703, participant, student, unknown sex</p></person>
<personGrp id="ss" role="audience" size="l"><p>ss, audience, large group </p></personGrp>
<personGrp id="sl" role="all" size="l"><p>sl, all, large group</p></personGrp>
<personGrp role="speakers" size="10"><p>number of speakers: 10</p></personGrp>
</particDesc>
<textClass>
<keywords>
<list>
<item n="speechevent">Lecture</item>
<item n="acaddept">Computer Science</item>
<item n="acaddiv">ps</item>
<item n="partlevel">UG1</item>
<item n="module">Introduction to systems</item>
</list></keywords>
</textClass> 
</profileDesc></teiHeader><text><body>
<u who="nm0696"> morning everybody <pause dur="1.1"/> last time we <pause dur="1.3"/> it started to build a model of the <pause dur="0.7"/> Motorola sixty-eight-thousand <pause dur="0.8"/> and # <pause dur="0.9"/> this included two models that we're going to <trunc>l</trunc> have to look at the memory model that was how long <pause dur="0.3"/> do we store information <pause dur="0.5"/> in the memory <pause dur="1.3"/> now they that can be instructions or data <pause dur="0.6"/> # <pause dur="0.4"/> but <pause dur="2.4"/> as far as the memory's concerned they <pause dur="0.2"/> are <pause dur="0.4"/> synonymous they are equivalent <pause dur="2.3"/> and # <pause dur="1.4"/> we could store information as bytes words and long words <pause dur="0.6"/> and <pause dur="2.3"/> to actually access that information <pause dur="0.3"/> we have to specify <pause dur="0.2"/> a memory address <pause dur="1.4"/> the processor <pause dur="0.3"/> we started looking at the processor model <pause dur="0.3"/> and here <pause dur="0.3"/> looked at the <pause dur="0.4"/> data registers <pause dur="0.3"/> # address registers although we're not terribly interested until <pause dur="0.2"/> the next phase of the course <pause dur="0.7"/> and <pause dur="0.5"/> some <pause dur="0.3"/> detailed <pause dur="0.6"/> # <pause dur="0.5"/> look at the user byte of the <pause dur="0.3"/> status register <pause dur="1.5"/> now what we're going to do today <pause dur="0.3"/> is to <pause dur="0.3"/> refine that model <pause dur="1.4"/> by <pause dur="1.1"/> looking at a typical instruction i will use add <pause dur="0.2"/> as the # <pause dur="0.4"/> running example <pause dur="0.7"/> # <pause dur="0.4"/> look at the instruction format <pause dur="1.8"/> both <pause dur="0.2"/> as <pause dur="0.2"/> the <pause dur="0.3"/> assembler level <pause dur="0.2"/> and <pause dur="0.4"/> # 
eventually the <pause dur="0.4"/> # instruction format level <pause dur="1.6"/> we'll then <pause dur="0.2"/> look at <pause dur="0.3"/> addressing modes which we'll find <pause dur="0.6"/> this is how <pause dur="0.3"/> we're going to access the operands of the instruction <pause dur="3.6"/> we'll also <pause dur="0.2"/> define a notation to describe the operation of the <pause dur="0.5"/> # <pause dur="0.2"/> of instructions <pause dur="1.0"/> okay the this this will <pause dur="0.2"/> enable us to <pause dur="0.5"/> have <pause dur="0.2"/> a summary sheet of all the instructions of the machine that you're going to need to know about <pause dur="0.4"/> and a precise <pause dur="0.2"/> description <pause dur="0.3"/> as to <pause dur="0.2"/> what happens when they are executed <pause dur="1.0"/> and finally <pause dur="0.7"/> we'll look at the <pause dur="0.3"/> if i i hope i have time to look at the instruction cycle <pause dur="0.4"/> when <pause dur="0.5"/> this is how <pause dur="0.2"/> the processor <kinesic desc="puts on transparency" iterated="n"/> actually executes a program <pause dur="1.2"/> okay <pause dur="9.8"/> now <pause dur="0.6"/> the <pause dur="2.6"/> execution of most instructions means that <pause dur="0.5"/> an operation <pause dur="0.2"/> is applied <pause dur="0.2"/> to two <pause dur="0.2"/> operands <pause dur="0.7"/> say most <pause dur="0.2"/> because there will be <pause dur="0.4"/> # other sorts of instruction but let's focus on <pause dur="0.6"/> the set of instructions which <pause dur="0.2"/> have <pause dur="0.2"/> two operands <pause dur="1.3"/> and <pause dur="0.5"/> once that <pause dur="0.6"/> # <pause dur="0.3"/> instruction's executed <pause dur="0.2"/> that <pause dur="0.2"/> delivers a result <pause dur="1.5"/> as as i <pause dur="0.3"/> said <pause dur="0.4"/> a minute ago <pause dur="0.8"/> we'll use integer # addition <pause dur="0.2"/> as our <pause dur="0.2"/> running 
example <pause dur="0.3"/> to introduce the various concepts of this lecture <pause dur="0.4"/> and here <pause dur="0.8"/> we've added two <pause dur="0.3"/> # <pause dur="0.5"/> integers together to get a result <pause dur="2.0"/> this will be operand one <pause dur="0.5"/> the operation is plus <pause dur="0.6"/> the operand is two <pause dur="0.5"/> and the result <pause dur="0.6"/> is <pause dur="0.2"/> i hope a thousand-and-eighteen <pause dur="1.7"/> now as far as the machine is concerned <pause dur="0.6"/> the operands can be <pause dur="0.3"/> located <pause dur="0.5"/> either in data registers <pause dur="0.2"/> or <pause dur="0.5"/> in <pause dur="0.4"/> the memory <pause dur="1.1"/> so there's two places it can be <pause dur="3.1"/> where <pause dur="0.2"/> will the result be put <pause dur="0.2"/> well in fact <pause dur="0.2"/> again <pause dur="0.2"/> we want to <pause dur="1.1"/> replace the result <pause dur="0.3"/> in R or record it <pause dur="0.3"/> in <pause dur="0.4"/> data register or a memory location <pause dur="3.1"/> now <pause dur="1.9"/> as i've said we're not <pause dur="1.1"/> terribly interested in address registers as yet <pause dur="0.3"/> but we'll be able to do similar things with those <pause dur="0.2"/> as <pause dur="0.2"/> well we're going to defer that <pause dur="0.4"/> and focus on <pause dur="0.4"/> data registers only <pause dur="0.8"/> or data registers in memory locations shall we say <pause dur="6.4"/><kinesic desc="changes transparency" iterated="y" dur="8"/> so the first thing is how does the machine <pause dur="0.2"/> add <pause dur="0.4"/> two things together <pause dur="1.2"/> well <pause dur="0.7"/> first of all <pause dur="0.6"/> i'll put up a <pause dur="1.6"/> a similar source instruction <pause dur="0.2"/> okay because <pause dur="0.6"/> that <pause dur="1.2"/> is one 
level <pause dur="0.3"/> of <pause dur="0.9"/> understanding what an instruction is we can specify what the assembler source is <pause dur="1.2"/> in here <pause dur="0.5"/> we said <pause dur="0.5"/> add <pause dur="1.0"/> dot-<pause dur="0.3"/>L <pause dur="1.0"/> D-two comma <pause dur="0.3"/> D-five <pause dur="0.3"/> now <pause dur="0.5"/> D-two and D-five <pause dur="0.2"/> clearly refer to two <pause dur="0.4"/> specific registers in the machine <pause dur="0.7"/> add is what we want to do <pause dur="0.4"/> and the L is the length of the operand in fact <pause dur="0.2"/> it's <pause dur="0.3"/> added <pause dur="0.2"/> two <pause dur="0.3"/> long words together <pause dur="1.7"/> now D-two <pause dur="1.2"/> contains the source operand <pause dur="0.8"/> all this is now a technical term as far as the machine is concerned <pause dur="0.4"/> D-two <pause dur="0.4"/> <trunc>i</trunc> will <pause dur="0.2"/> # refer to a source operand <pause dur="0.4"/> and <pause dur="0.2"/> D-five <pause dur="0.3"/> a destination operand <pause dur="2.4"/> so what actually happens <pause dur="0.3"/> come on let's draw a little diagram <pause dur="0.3"/> as to <pause dur="0.9"/> what the <pause dur="0.2"/> value <pause dur="0.2"/> of the registers data registers are before we execute the instruction <pause dur="0.2"/> they will have some value <pause dur="1.6"/> the value there are although i haven't explicitly said <pause dur="0.5"/> is <pause dur="0.9"/> expressed in hex <pause dur="0.4"/> hexadecimal that's right we introduced that last term <pause dur="0.6"/> and if you want to <trunc>de</trunc> describe precisely what <pause dur="0.3"/> thirty-two bit values are <pause dur="0.3"/> then <pause dur="0.3"/> we <pause dur="0.4"/> use <pause dur="2.0"/> the <pause dur="0.5"/> # <pause dur="0.2"/> hex to do it <pause dur="2.2"/> so <pause dur="0.3"/> the first thing is that the <pause dur="0.3"/> processor has to fetch the operands to do the 
operation and so okay let's take copies of <pause dur="0.7"/> D-two and D-five <pause dur="0.8"/> all right <pause dur="0.3"/> which is here <pause dur="0.7"/> and we add them together <pause dur="0.8"/> and i hope i've done the <trunc>adda</trunc> addition <pause dur="0.4"/> correctly <pause dur="1.4"/> now clearly <pause dur="0.7"/> a processor will have <pause dur="0.2"/> internal registers <pause dur="0.5"/> to store these things in <pause dur="1.1"/> to do the copying <pause dur="0.3"/> 'cause it works on copies <pause dur="2.0"/> however <pause dur="0.3"/> we have no access to that <pause dur="0.4"/> and we don't need to <pause dur="0.2"/> at this stage <pause dur="0.4"/> go down to that level of a model <pause dur="0.2"/> we just have to <pause dur="0.8"/> # <pause dur="0.6"/> think well it's there and that's how it does it <pause dur="0.4"/> but <pause dur="0.3"/> exactly how it does it is too much detail for us <pause dur="0.9"/> if you wanted to actually design a processor a half adder and that sort of thing then <pause dur="0.4"/> that's what's would be of interest <pause dur="0.2"/> but <pause dur="0.3"/> no we're staying at a higher level than that <pause dur="1.6"/> so <pause dur="0.3"/> it can then do the the addition <pause dur="0.8"/> and in fact <pause dur="0.2"/> it stores the result back <pause dur="0.4"/> in <pause dur="0.4"/> the <pause dur="0.5"/> # destination <pause dur="0.2"/> operand which is in fact why <pause dur="0.4"/> here we go <pause dur="0.2"/> why the <pause dur="0.7"/> # <pause dur="0.2"/> D-five is called the destination <pause dur="0.2"/> it's <pause dur="0.6"/> the destination of the result <pause dur="15.8"/><kinesic desc="changes transparency" iterated="y" dur="10"/> well let's <pause dur="2.7"/> look at the <pause dur="0.2"/> 
structure of the assembler source <pause dur="0.3"/> # in the first <pause dur="0.4"/> # instance <pause dur="1.5"/> here <pause dur="3.4"/> first of all <pause dur="0.2"/> the add <pause dur="0.5"/> is a mnemonic it's a mnemonic for the operations <pause dur="0.3"/> and all the operations of the machine had their own mnemonic as far as the assembler is concerned <pause dur="2.0"/> the <pause dur="0.4"/> # <pause dur="1.4"/> L as i mentioned last time was the length of the operand <pause dur="0.5"/> and here is the source <pause dur="0.7"/> and <pause dur="0.6"/> the destination <pause dur="0.5"/> # <pause dur="1.2"/> operands but <pause dur="0.7"/> note <pause dur="0.6"/> that they are specified <pause dur="0.2"/> by <pause dur="0.3"/> quoting <pause dur="0.6"/> the <pause dur="0.2"/> the address <pause dur="0.2"/> of the registers <pause dur="1.4"/> okay <pause dur="1.0"/> the operands themselves are the contents of registers <pause dur="1.7"/> all right <pause dur="0.2"/> but <pause dur="0.2"/> but we write the instruction <pause dur="1.6"/> by <pause dur="0.4"/> quoting <pause dur="0.3"/> the address <pause dur="0.5"/> where <pause dur="0.3"/> the operand <pause dur="0.2"/> can be found <pause dur="1.0"/> now this is an example of <pause dur="0.7"/> what's called data register direct <pause dur="0.3"/> an addressing mode <pause dur="2.1"/> and <pause dur="0.7"/> we're going to construct instructions <pause dur="0.2"/> out of essentially <pause dur="0.3"/> operands and addressing modes <pause dur="1.8"/> all right <pause dur="2.6"/> the addressing mode specifies how do i obtain the operand <pause dur="2.2"/> now <pause dur="1.3"/> the assembler program <pause dur="0.2"/> that is the the # will <pause dur="0.3"/> take <pause dur="1.4"/> this source <pause dur="0.4"/> and <pause dur="0.2"/> map it <pause dur="0.5"/> into or convert it into a single <pause dur="0.3"/> machine <pause dur="0.6"/> code <pause dur="0.6"/> word <pause dur="2.6"/> okay so that <pause dur="1.8"/> what we'll 
look at first <pause dur="1.0"/> is <pause dur="1.0"/><kinesic desc="changes transparency" iterated="y" dur="8"/> how can we describe <pause dur="0.6"/> that <pause dur="1.1"/> # <pause dur="0.8"/> operation <pause dur="0.4"/> execution <pause dur="0.2"/> or the <trunc>ar</trunc> the instruction execution <pause dur="3.6"/> we need a notation <pause dur="0.5"/> because <pause dur="0.5"/> # <pause dur="2.0"/> you can describe it in words and <pause dur="0.2"/> that's what i'm doing at the moment <pause dur="0.2"/> but <pause dur="0.3"/> always <pause dur="0.3"/> it's <pause dur="0.2"/> a lot easier if you have a notation <pause dur="0.4"/> we would like a notation to <pause dur="0.2"/> have various properties and and <pause dur="0.3"/> certainly the what the requirements here would be is compact <pause dur="0.3"/> all right we're always seeking <pause dur="0.3"/> a compact expression that's what <pause dur="0.6"/> why mathematics is so important to physics it allows <pause dur="0.7"/> the expression the model <pause dur="0.4"/> in <pause dur="0.3"/> compact <pause dur="0.3"/> terms <pause dur="0.2"/> and with <pause dur="0.2"/> precision <pause dur="2.7"/> so <pause dur="0.8"/> we could <pause dur="0.8"/> here we are <pause dur="0.2"/> i'll informally describe <pause dur="0.5"/> the add instruction <pause dur="1.1"/> by <pause dur="0.7"/> # <pause dur="3.1"/> here <pause dur="0.8"/> all right <pause dur="0.8"/> now <pause dur="1.2"/> that <pause dur="1.4"/> describes exactly what it does <pause dur="0.4"/> but we need to <pause dur="0.2"/> explain <pause dur="0.3"/> what are the brackets and so on <pause dur="1.3"/> first of all <pause dur="0.6"/> interpret <pause dur="1.1"/> brackets X <pause dur="0.4"/> as being <pause dur="0.2"/> the contents of X <pause dur="1.9"/> okay <pause dur="0.5"/> plus <pause dur="0.5"/> is the addition operator <pause dur="1.0"/> and <pause dur="0.4"/> becomes equals is the assignment or replacement operator <pause dur="0.8"/> so i've tried to make it look <pause dur="0.2"/> 
like <pause dur="1.4"/> an addition <pause dur="1.3"/> in <pause dur="1.1"/> back up <pause dur="2.3"/> okay <pause dur="4.0"/> it's not quite the same <pause dur="0.5"/> clearly <pause dur="0.2"/> we have to be explicitive <pause dur="0.2"/> we would normally just quote <pause dur="0.2"/> the variable name <pause dur="0.4"/> yeah <pause dur="2.1"/> but what we're doing here <pause dur="0.2"/> we had to say exactly <pause dur="0.6"/> where <pause dur="1.0"/> the operand <pause dur="0.3"/> is <pause dur="2.4"/> now we'll need <pause dur="0.5"/> in our notation we'll need somehow <pause dur="0.3"/> to <pause dur="0.5"/> # <pause dur="0.2"/> refer to <pause dur="1.1"/> registers <pause dur="0.2"/> constants <pause dur="0.2"/> memory addresses <pause dur="0.3"/> in a generic way in other words <pause dur="0.3"/> we'll <pause dur="0.2"/> <trunc>i</trunc> or <kinesic desc="changes transparency" iterated="y" dur="10"/> symbolic way <pause dur="1.8"/> and <pause dur="0.8"/> here <pause dur="8.1"/> if you want to <pause dur="1.1"/> refer to a register <pause dur="0.5"/> data register then it's <pause dur="0.2"/> capital-D-N where <pause dur="0.3"/> # that is any <pause dur="0.6"/> data register <pause dur="0.2"/> all right <pause dur="1.2"/> and A-N will be an address register <pause dur="1.0"/> sometimes we'll want to say it could be either <pause dur="0.7"/> in which case we'll use X <pause dur="1.7"/> and P-C <pause dur="0.9"/> will be <pause dur="0.4"/> a program constant <pause dur="0.2"/> so these these are the registers <pause dur="1.0"/> memory <pause dur="1.3"/> we'll just say <pause dur="0.7"/> a thirty-two <pause dur="0.2"/> bit <pause dur="0.2"/> memory address and we'll call that <pause dur="0.2"/> M-<pause dur="0.4"/>subscript-thirty-two <pause dur="0.9"/> 
constants <pause dur="0.9"/> <unclear>with a</unclear> vary we'll want to have eight <pause dur="0.8"/> # sixteen and thirty-two bit constants <pause dur="0.3"/> and here <pause dur="0.5"/> we'll just use D-sub-<pause dur="0.4"/>eight <pause dur="0.3"/> sixteen and so on <pause dur="0.6"/> and <pause dur="0.6"/> D-N if you want to <pause dur="0.8"/> refer to <pause dur="0.5"/> # any one of those <pause dur="0.2"/> three <pause dur="4.6"/> we need this because <pause dur="2.8"/> let's move on to say <pause dur="0.6"/> we've looked at <pause dur="0.4"/> informally one <pause dur="0.9"/> # <pause dur="1.0"/> simple addressing mode <pause dur="0.2"/> data register direct <pause dur="0.5"/> as far as the first <pause dur="0.3"/><kinesic desc="changes transparency" iterated="y" dur="20"/> or the next <pause dur="1.3"/> four or five lectures are concerned <pause dur="0.8"/> then <pause dur="2.5"/> we only need <pause dur="0.5"/> the following <pause dur="0.6"/> # operands we can do all we need to <pause dur="0.6"/> # <pause dur="1.1"/> for that stage 'cause they we're excluding <pause dur="0.2"/> address registers <pause dur="1.8"/> okay <pause dur="1.4"/> now <pause dur="3.4"/> this is where this notation starts coming in <pause dur="0.5"/> okay because <pause dur="0.6"/> here <pause dur="1.2"/> we can say <pause dur="0.2"/> for a data register direct <pause dur="1.2"/> then <pause dur="2.0"/> the operand <pause dur="0.2"/> address <pause dur="1.0"/> is D-N <pause dur="1.0"/> okay <pause dur="2.1"/> the operand value <pause dur="1.0"/> is <pause dur="1.6"/> the contents <pause dur="0.4"/> D-N <pause dur="1.3"/> okay <pause dur="1.0"/> and so this is <pause dur="0.2"/> essentially the <pause dur="0.2"/> the usage <pause dur="2.6"/> now <pause dur="0.9"/> that's fine <pause dur="0.5"/> # <pause dur="0.4"/> however <pause dur="2.4"/> was <pause dur="0.4"/> i would think one of the # <pause dur="2.7"/> most frequent <pause dur="0.3"/> Pascal <pause dur="0.8"/> statements you'll write is X becomes X-plus-one <pause dur="0.2"/> yeah <pause dur="3.1"/> so <pause dur="0.2"/> one 
is a constant <pause dur="0.3"/> so <pause dur="0.6"/> we do need to have down at the machine level <pause dur="0.7"/> the ability to <pause dur="0.5"/> # <pause dur="1.3"/> incorporate <pause dur="0.5"/> constants into instructions <pause dur="1.3"/> okay so here <pause dur="0.5"/> we'll call this is an immediate addressing mode <pause dur="1.2"/> and <pause dur="0.2"/> the operand address is D-N <pause dur="1.3"/> but that's <pause dur="0.5"/> the <trunc>s</trunc> <pause dur="0.2"/> we use the address as the <pause dur="0.5"/> operand <pause dur="0.3"/> value <pause dur="1.5"/><kinesic desc="changes transparency" iterated="y" dur="8"/> okay now this is slightly different to <pause dur="0.3"/> the notes i will issue a a correction to that <pause dur="0.5"/> okay <pause dur="2.4"/> # <pause dur="3.6"/> the # <pause dur="2.1"/> as <pause dur="0.9"/> so far <pause dur="0.7"/> how that's how we can <pause dur="0.3"/> incorporate constants <pause dur="0.7"/> we can incorporate the contents of <pause dur="0.2"/> # <pause dur="0.5"/> registers <pause dur="0.2"/> what about the contents of memory location <pause dur="0.5"/> well here <pause dur="0.3"/> we use <pause dur="0.2"/> addressing mode <pause dur="0.2"/> absolute long address <pause dur="1.5"/> here <pause dur="0.3"/> the operand <pause dur="0.3"/> is M-thirty-two <pause dur="0.3"/> thirty-two bit memory address <pause dur="1.0"/> and <pause dur="0.3"/> the operand value <pause dur="0.8"/> is <pause dur="0.2"/> the contents <pause dur="0.4"/> of that address <pause dur="4.5"/> now <pause dur="2.9"/> in <pause dur="1.6"/> developing our symbolic <pause dur="0.2"/> # <pause dur="0.5"/> operation <pause dur="0.2"/> description <pause dur="1.1"/> if we want to put it any further then <pause dur="0.6"/> we'll need to relate <pause dur="1.1"/> all of this to <pause dur="0.4"/> the assembler form <pause dur="1.6"/> okay now <pause dur="0.5"/> let's let's think what the assembler form was it was a mnemonic an operation <pause dur="1.1"/> okay <pause dur="0.4"/> plus <pause dur="0.4"/> an address part <pause dur="0.3"/> which involved two 
addresses <pause dur="1.2"/> and <pause dur="0.2"/> specifically <pause dur="0.7"/> the addressing mode <pause dur="1.4"/> and that is the addressing mode <pause dur="0.5"/> of the source operand <pause dur="0.5"/> there's a comma <pause dur="0.3"/> and addressing mode <pause dur="0.2"/> of the destination operand <pause dur="1.8"/> okay <pause dur="1.2"/> so <pause dur="6.5"/><kinesic desc="changes transparency" iterated="y" dur="15"/> so <pause dur="3.1"/> let's look at our <pause dur="2.9"/> how do are we going to <pause dur="0.4"/> write in an instruction to select the addressing mode that we want because that's what a <pause dur="0.4"/> writing a machine or an assembler <pause dur="0.2"/> instruction <pause dur="1.3"/> pick the mnemonic you want <pause dur="0.9"/> and then the two addressing modes that you <pause dur="0.2"/> need <pause dur="3.9"/> data register direct <pause dur="0.5"/> here we are <pause dur="2.1"/> assembler source is D-N <pause dur="1.8"/> and examples would be <pause dur="0.2"/> D-five D-nought and so on <pause dur="2.4"/> immediate <pause dur="0.9"/> essentially how are we going to write constants in the assembly language <pause dur="2.0"/> hash-D-N <pause dur="0.7"/> or hash-dollar-D-N <pause dur="1.2"/> don't <pause dur="1.0"/> ask me why <pause dur="0.2"/> people select this it's <trunc>n</trunc> <pause dur="0.9"/> # <pause dur="3.2"/> partly historical <pause dur="0.5"/> however <pause dur="1.5"/> we would actually write hash-two-four-seven or <pause dur="0.4"/> hash-dollar eighty-three <pause dur="0.6"/> there's two examples <pause dur="0.9"/> absolute long address <pause dur="1.3"/> M-<pause dur="0.6"/>thirty-two or dollar-M-thirty-two <pause dur="0.4"/> and you so <pause dur="0.3"/> we could write 
hundred or <pause dur="0.2"/> dollar-hundred so what does that mean <pause dur="0.3"/> the hash character <pause dur="0.7"/> is how we specify in the assembly language that we want the immediate address of that <pause dur="0.7"/> all right <pause dur="0.3"/> so that's the first bit <pause dur="1.6"/> dollar <pause dur="0.5"/> indicates <pause dur="0.3"/> that it's a hex constant that follows rather than <pause dur="0.3"/> a <pause dur="0.4"/> # <pause dur="2.7"/> a decimal <pause dur="3.9"/> so <pause dur="1.1"/> if we want to symbolically <pause dur="0.3"/> in our notation <pause dur="0.2"/> # in <pause dur="0.2"/> in # <pause dur="0.2"/> our notation for operations then <pause dur="0.5"/> we will <pause dur="0.9"/> # <pause dur="0.9"/> if you want to refer to <pause dur="0.2"/> an immediate mode we'll write hash-data <pause dur="3.9"/> but <pause dur="1.9"/> there are <pause dur="0.2"/> another four or five well may maybe more <pause dur="0.2"/> addressing modes to come all right we won't frighten ourselves at this point to to before we do it but <pause dur="0.3"/> there are <pause dur="0.2"/> a whole set to come <pause dur="1.5"/> in the spirit that we want to have a truly general <pause dur="0.6"/> symbolic way of of describing things <pause dur="0.8"/> we need a way to say <pause dur="1.6"/> can i write down something <pause dur="0.2"/> which represents <pause dur="0.3"/> any <pause dur="0.6"/> addressing mode <pause dur="2.1"/> and the way that <pause dur="0.3"/> Motorola <trunc>choo</trunc> chose to do it was to <pause dur="0.6"/> # invent a a term <pause dur="0.4"/> called <pause dur="0.2"/> effective address <pause dur="1.5"/> right <pause dur="0.4"/> so <pause dur="0.5"/> effective address <pause dur="0.4"/><kinesic desc="changes transparency" iterated="y" dur="18"/> could be <pause dur="0.7"/> any <pause dur="0.5"/> of <pause dur="0.8"/> these <pause dur="0.5"/> addressing <pause dur="0.3"/> 
modes <pause dur="8.1"/> we're now at a point where we can take our add and do a bit more <pause dur="0.3"/> put it all together so let's try <pause dur="0.3"/> # <pause dur="0.5"/> move on to that <pause dur="9.1"/> first of all <pause dur="0.2"/> there are <pause dur="0.3"/> two <pause dur="0.3"/> variants of add <pause dur="2.4"/> okay <pause dur="1.3"/> add <pause dur="1.9"/> and now i'm using the notation <pause dur="0.2"/> effective address <pause dur="0.6"/> so it can be <pause dur="0.6"/> in our terms <pause dur="0.7"/> # <pause dur="2.5"/> possibly <pause dur="0.4"/> # <pause dur="0.6"/> a data register <pause dur="1.5"/> address <pause dur="1.6"/> hash-data or M-thirty-two and a memory address <pause dur="0.8"/> so here <pause dur="0.2"/> we can add <pause dur="0.8"/> effective address D-N <pause dur="0.2"/> and we can write using our notation that the <pause dur="0.5"/> contents <pause dur="0.4"/> of <pause dur="0.9"/> the data register becomes the contents of a data register plus <pause dur="0.4"/> the contents of the effective address <pause dur="3.5"/> and <pause dur="0.7"/> we reverse D-N and E-A <pause dur="0.6"/> and now <pause dur="0.4"/> we can add <pause dur="0.2"/> the contents of a data register <pause dur="0.4"/> to anything else <pause dur="0.7"/> our simple <pause dur="0.3"/> effective addresses <pause dur="0.3"/> can be D-N-<pause dur="0.3"/>hash-data and M-thirty-two <pause dur="2.3"/> why have we got two variants <pause dur="0.5"/> right why are there two <pause dur="1.1"/> well the problem is is <pause dur="0.2"/> how we get down to express things at the <pause dur="0.9"/> instruction format level <pause dur="0.4"/> okay <pause dur="1.8"/> because <pause dur="0.3"/> if you look at <pause dur="2.6"/> what the instruction format <pause dur="1.2"/> is like <pause dur="0.3"/> you know <pause dur="0.3"/> # <vocal desc="clears throat" iterated="n"/> what this is is a number of fields bit 
fields <pause dur="0.7"/> within <pause dur="0.7"/> # <pause dur="0.6"/> either a word or a long word or certainly can be more than that <pause dur="1.6"/> first of all <pause dur="1.2"/> an operation code and that <pause dur="0.5"/> corresponds to the fact that it's an adding structure <pause dur="1.7"/> the register <pause dur="0.2"/> address D-N <pause dur="2.0"/> okay <pause dur="1.7"/> operation mode <pause dur="0.6"/> which we'll <pause dur="0.8"/> look at in a minute <pause dur="0.2"/> and an effective <pause dur="0.8"/> address <pause dur="1.8"/> well i want you do a little bit now i've been talking for twenty minutes about time you did something <pause dur="0.3"/> so <pause dur="0.5"/> write down all the possible <pause dur="0.9"/> forms all right <pause dur="0.9"/> for <pause dur="0.2"/> variants one and two <pause dur="0.9"/> okay <pause dur="0.5"/> so do that <pause dur="1.3"/> write them down <pause dur="28.0"/> it's the same as last time <pause dur="2.3"/> it is the same as last time i think </u><pause dur="0.3"/> <u who="sm0697" trans="pause"> <gap reason="inaudible" extent="1 sec"/></u><pause dur="0.3"/> <u who="nm0696" trans="pause"> mm </u><pause dur="1:28.0"/> <u who="nm0696" trans="pause"> okay <pause dur="0.7"/><kinesic desc="changes transparency" iterated="y" dur="6"/> that's your lot <pause dur="1.6"/> mine aren't <pause dur="0.3"/> terribly neat <pause dur="0.2"/> but # <pause dur="2.8"/> and i got one wrong while i was writing it out but i've got a permanent pen so i can't <pause dur="0.7"/> get rid of it <pause dur="1.3"/> okay <pause dur="1.4"/> if you look at variant one then <pause dur="1.3"/> the <pause dur="5.2"/> i am trying to get it all on one <pause dur="0.6"/> side here <pause dur="1.7"/> write down the ones at variant one then <pause dur="0.3"/> just adding two registers together <pause dur="1.2"/> add D-one <pause dur="0.3"/> hash-data <pause dur="0.2"/> add D-one <pause dur="0.2"/> M-thirty-two <pause dur="0.3"/> yeah people get that <pause dur="1.9"/> let me write the same thing down <pause dur="0.6"/> for this one <pause dur="3.6"/> what are the 
limitations of variant one <pause dur="0.4"/> anybody like to # <pause dur="8.0"/> hazard a guess <pause dur="12.0"/> i've got one wrong again people aren't # <pause dur="3.1"/> shall i start again <pause dur="0.5"/><vocal desc="laughter" iterated="y" dur="1"/><pause dur="1.3"/> 
you're not very confident are you <pause dur="7.0"/><kinesic desc="changes transparency" iterated="y" dur="16"/> # i hope i've got another slide here <pause dur="7.3"/> should have done it with a slide <pause dur="4.1"/> if we're looking this one <pause dur="0.5"/> we would do <pause dur="0.5"/> D-one <pause dur="0.7"/> D-two <pause dur="20.3"/> yeah <pause dur="1.1"/> everybody got that <pause dur="2.4"/> so <pause dur="0.8"/> what's missing <pause dur="0.5"/> there's a <pause dur="6.7"/> well i can add <pause dur="1.2"/> here's the <pause dur="0.2"/> the destination i can add to a register <pause dur="0.3"/> the contents of a register <pause dur="1.1"/> the <pause dur="1.0"/> contents of another register <pause dur="0.9"/> constant <pause dur="0.8"/> the contents of a <pause dur="0.2"/> memory location <pause dur="0.9"/> what would i like to be able to do </u><pause dur="4.4"/> <u who="sm0698" trans="pause"> <gap reason="inaudible" extent="1 sec"/></u><pause dur="1.9"/> <u who="nm0696" trans="pause"> you're you're halfway there </u><pause dur="3.5"/> <u who="sm0698" trans="pause"> <gap reason="inaudible" extent="4 secs"/> </u><u who="nm0696" trans="latching"> yeah you're you're you're you're you're getting there <pause dur="0.4"/> i mean <pause dur="0.2"/> if if we write them down formally <pause dur="2.9"/> again <pause dur="3.3"/> # <pause dur="1.0"/> # D-<pause dur="1.4"/>three hash-data <pause dur="8.8"/> okay <pause dur="1.5"/> this one <pause dur="2.5"/> is how we add to <pause dur="0.3"/> memory <pause dur="0.2"/> we add a contents of a register to memory <pause dur="0.5"/> right <pause dur="0.3"/> just one of the options that <pause dur="0.5"/> we <pause dur="0.8"/> didn't we can't have <pause dur="0.2"/> you you you <pause dur="1.2"/> there is a restriction here <pause dur="0.5"/> in terms of what we could do <pause dur="0.7"/> so 
that one <pause dur="0.9"/> is a plus we need a variant two <pause dur="1.4"/> to be able to add the contents of a register to <pause dur="0.5"/> a memory location <pause dur="0.5"/> as opposed to <pause dur="0.2"/> the other way round <pause dur="1.4"/> yeah <pause dur="1.5"/> so <pause dur="0.5"/> that's the limitations we've only got <pause dur="0.4"/> we can't add to memory <pause dur="3.0"/> next thing <pause dur="0.3"/> do all of these make sense <pause dur="1.0"/> well <pause dur="0.2"/> by the fact i've asked the question the the answer is <pause dur="1.4"/> probably that not all of them do <pause dur="0.5"/> so what's one that's look <pause dur="0.3"/> looks pretty nonsensical <pause dur="0.2"/> to anybody <pause dur="0.2"/> you know that just doesn't look right </u><pause dur="1.9"/> <u who="sm0699" trans="pause"> constant </u><pause dur="0.4"/> <u who="nm0696" trans="pause"> constant yeah <pause dur="0.2"/> you can't add to a constant <pause dur="1.4"/> mm <pause dur="0.6"/> can't do it <pause dur="1.4"/> so we'd rule that out <pause dur="1.3"/> now <pause dur="1.6"/> formally <pause dur="0.5"/> in fact <pause dur="0.4"/> this one's wrong <pause dur="1.3"/> although <pause dur="0.4"/> it looks the same form as that in fact <pause dur="0.7"/> it # <pause dur="0.5"/> we'll need to think about that a little bit more and i'll i'll <trunc>ex</trunc> <pause dur="0.2"/> i'll explore that on the next transparency <pause dur="4.8"/><kinesic desc="changes transparency" iterated="y" dur="9"/> so <pause dur="6.3"/> to summarize where where we've got to out of that slide <pause dur="0.3"/> we've got <pause dur="0.9"/> two variants because of the <trunc>astra</trunc> the the fact you <pause dur="1.8"/> have a fixed way of of <pause dur="0.6"/> # <pause dur="1.4"/> encoding an instruction <pause dur="1.9"/> here this form <pause dur="0.5"/> there is no restriction there are no addressing modes that 
we can't use <pause dur="0.9"/> in here <pause dur="0.5"/> we can use all three that we <pause dur="0.4"/> introduced <pause dur="0.5"/> here <pause dur="0.4"/> we can't use <pause dur="0.4"/> hash-data <pause dur="0.2"/> D-N <pause dur="0.5"/> and i've included for competeless A-N <pause dur="0.9"/> all right <pause dur="1.7"/> now <pause dur="3.4"/> the reason that you <pause dur="0.6"/> strictly speaking informally we we get rid of that is that <pause dur="0.2"/> D-N <pause dur="0.3"/> acts as a destination in variant one <pause dur="0.7"/> and a source <pause dur="0.2"/> in variant two <pause dur="0.4"/> all right this this <pause dur="0.4"/> this register address here <pause dur="1.1"/> okay <pause dur="3.2"/> the operation mode field contains a bit to say <pause dur="0.3"/> that's a direction which is going that <pause dur="0.3"/> that selects whether that register is the source or destination <pause dur="2.4"/> with me <pause dur="4.1"/> so obviously as we saw the hash-data we can't because it's a destination operand <pause dur="0.6"/> we informally exclude D-N from the <pause dur="0.4"/> here because <pause dur="2.8"/> list of allowed <pause dur="0.9"/> but <pause dur="0.6"/> it's not really a problem because the assembler will always select the right <pause dur="1.7"/> binary for us <pause dur="1.5"/> A-N <pause dur="1.3"/> here <pause dur="0.3"/> you <pause dur="0.6"/> you've only got three bits to represent <pause dur="0.8"/> a register address <pause dur="1.0"/> you can't tell whether it's a <pause dur="1.7"/> data or an address register <pause dur="0.6"/> so you have to have another operation to do it <pause dur="2.6"/> next time i'll be handing out a list of 
instructions <pause dur="0.4"/> where <pause dur="0.6"/> it includes all of these <pause dur="0.7"/> lists <pause dur="0.2"/> with these operations and restrictions <pause dur="0.5"/> and <pause dur="0.6"/> this should be about two two B-L to interpret it <pause dur="2.5"/><kinesic desc="changes transparency" iterated="y" dur="22"/> any questions at this point <pause dur="5.3"/> okay <pause dur="15.9"/> okay <pause dur="0.3"/> let's # <pause dur="7.1"/> just look at some examples <pause dur="0.2"/> with the the assembler and the <pause dur="0.4"/> # taking the <pause dur="0.4"/> general notation <pause dur="0.3"/> and then <pause dur="0.2"/> making it specific to this particular instruction <pause dur="1.8"/> add D-two to D-six this is the one we typically the one <trunc>w</trunc> we looked at before <pause dur="0.8"/> D-six <pause dur="0.3"/> becomes D-six plus D-two and in this case <pause dur="0.2"/> E-A <pause dur="0.3"/> is <pause dur="0.4"/> D-<pause dur="0.6"/>two <pause dur="0.4"/> yeah <pause dur="1.2"/> the effective address is D-two <pause dur="2.4"/> here <pause dur="3.7"/> i've slipped in <pause dur="0.9"/> dollar-a-hundred <pause dur="1.0"/> all right <pause dur="2.4"/> and what that means is <pause dur="0.3"/> that i'm going to add the contents <pause dur="0.2"/> of memory address <pause dur="3.3"/> a hundred hex <pause dur="2.6"/> <unclear>come on</unclear> <pause dur="1.5"/> and add it to D-nought <pause dur="1.2"/> okay in this case <pause dur="0.3"/> the effective address <pause dur="0.6"/> is <pause dur="0.3"/> a hundred <pause dur="0.2"/> hex <pause dur="4.0"/> okay <pause dur="0.3"/> here <pause dur="2.0"/> we want to add a constant <pause dur="0.6"/> and so <pause dur="1.7"/> i could just use add <pause dur="0.3"/> hash-one-two-three <pause dur="0.8"/> to <pause dur="0.2"/> D-three <pause dur="1.4"/> and there we can do add a constant <pause dur="1.3"/> we will see later on <pause dur="0.3"/> that there are instructions which <pause dur="0.4"/> # <pause dur="6.9"/> let you <pause dur="0.3"/> # specify <pause dur="0.2"/> essentially <pause dur="0.2"/> you want an immediate address 
form as well <pause dur="1.1"/> they're there <pause dur="0.4"/> for efficiency reasons the architecture runs a bit faster for those <pause dur="3.0"/> variant two <pause dur="0.2"/> and this is the only one that we can use with these <pause dur="0.2"/> out of our <pause dur="0.5"/> three <pause dur="0.5"/> # <pause dur="2.0"/> simple addressing modes <pause dur="0.3"/> here <pause dur="0.3"/> we can add <pause dur="0.6"/> the contents of a register <pause dur="1.6"/> and i'd always make a mistake on a slide so <pause dur="0.3"/> here we go that should be brackets <pause dur="5.1"/> and the effect of address in this case <pause dur="1.9"/> is <pause dur="0.8"/> three <pause dur="0.4"/><vocal desc="clears throat" iterated="n"/><pause dur="5.9"/> okay <pause dur="0.4"/> write down all the addressing modes you can see there <pause dur="0.3"/> what are they <pause dur="3.0"/> for those four <pause dur="0.2"/> just write them down <pause dur="54.8"/> okay <pause dur="0.9"/> so what have i got here <pause dur="0.5"/> someone shout them out somebody <pause dur="0.6"/> just have a little bit of interaction <pause dur="1.4"/> what have i got here then <pause dur="1.3"/> what's this one <pause dur="6.1"/> oh dear oh dear </u><pause dur="0.9"/> <u who="sm0700" trans="pause"> is it data register direct </u><u who="nm0696" trans="latching"> that's right <pause dur="0.2"/> data register direct <pause dur="0.5"/> and so is that one <pause dur="1.8"/> okay <pause dur="3.7"/> what about that one </u><pause dur="16.4"/> <u who="sm0701" trans="pause"> absolute long address </u><pause dur="0.4"/> <u who="nm0696" trans="pause"> thank you <pause dur="1.4"/> absolute long <pause dur="0.2"/> address <pause dur="1.0"/> we're adding the contents of a memory register <pause dur="0.2"/> it's absolute long address <pause dur="0.3"/> again <pause dur="0.5"/> we have <pause dur="0.6"/> data register direct for the second one <pause dur="1.3"/> 
okay <pause dur="0.8"/> this one </u><pause dur="2.3"/> <u who="sm0702" trans="pause"> immediate </u><pause dur="0.3"/> <u who="nm0696" trans="pause"> immediate <pause dur="0.7"/> and <pause dur="0.2"/> data register direct <pause dur="1.1"/> and likewise here <pause dur="1.4"/> # <pause dur="0.5"/> the <pause dur="0.4"/> # <pause dur="0.3"/> memory address is there as well <pause dur="2.9"/> and so you've <trunc>do</trunc> we've done that already <pause dur="0.3"/> okay <pause dur="0.6"/> so <pause dur="3.3"/> and that's all we're going to do <pause dur="0.9"/> for <pause dur="0.4"/> all the instructions we're going to do for the first part of the course <pause dur="1.0"/> those are the three <trunc>ad</trunc> addressing modes we're going to do <pause dur="0.3"/> we're going to <pause dur="0.2"/> construct <pause dur="2.2"/> all right <pause dur="0.4"/> the instructions from <pause dur="1.2"/> two operands <pause dur="0.3"/> of which <pause dur="0.7"/> they'll be selected from <pause dur="0.7"/> one of those <pause dur="0.8"/> # <pause dur="0.2"/> three <pause dur="0.8"/><kinesic desc="changes transparency" iterated="y" dur="6"/> each of those will be one of those three <pause dur="0.7"/> # <pause dur="0.7"/> addressing modes <pause dur="1.4"/> so that's got <pause dur="0.2"/> addressing modes and we've got our notation <pause dur="0.3"/> going <pause dur="2.2"/> what i'm going to move on to now for the last part of the lecture is to <pause dur="0.3"/> look at <pause dur="1.2"/> construction execution <pause dur="2.2"/> 
okay <pause dur="0.4"/> which # <pause dur="6.2"/><kinesic desc="changes transparency" iterated="y" dur="9"/> but first of all <pause dur="1.5"/> just a little bit more <pause dur="1.3"/> on <pause dur="0.6"/> how <pause dur="7.3"/> binary instructions <pause dur="3.2"/> the <pause dur="1.8"/> we saw <pause dur="0.8"/> there is an operation word and this has got an operation code <pause dur="0.3"/> add sub <pause dur="0.4"/> et cetera <pause dur="1.3"/> it's <pause dur="0.6"/> got a <pause dur="0.8"/> either a <trunc>b</trunc> # it's got a register address <pause dur="0.4"/> it's got an operation mode <pause dur="1.3"/> and then <pause dur="0.3"/> there are two <pause dur="1.3"/> things here which essentially <pause dur="0.4"/> this <pause dur="2.8"/> is our <pause dur="2.2"/> effective address <pause dur="0.5"/> okay <pause dur="4.2"/> or the start of it anyway <pause dur="3.3"/> operation code <pause dur="0.3"/> three bit <pause dur="0.5"/> data or address registers our op mode <pause dur="0.6"/> there are three bits <pause dur="0.6"/> okay <pause dur="1.2"/> and a one bit code for this sort of instruction <pause dur="0.3"/> is a direction <pause dur="0.3"/> is <pause dur="0.7"/> which of the <pause dur="0.4"/> E-A and X-N <pause dur="0.2"/> are <pause dur="0.5"/> the source and destination <pause dur="0.6"/> right <pause dur="0.4"/> one means X-N is the source <pause dur="0.4"/> and nought means it's the destination <pause dur="1.1"/> size <pause dur="0.2"/> 
you got to <pause dur="0.3"/> encode the fact of how long the operand is <pause dur="1.1"/> so nought is # <pause dur="0.3"/><vocal desc="cough" iterated="y" dur="1"/><pause dur="0.3"/> bytes <pause dur="0.7"/> one is words <pause dur="0.3"/> and one-zero-<pause dur="0.2"/>two is long words <pause dur="1.9"/> mode and register <pause dur="0.3"/> that's the minimum <pause dur="0.2"/> specification <pause dur="0.3"/> of <pause dur="0.7"/> a <pause dur="1.1"/> an effective address <pause dur="0.7"/> and it would select typically <pause dur="0.5"/> the <pause dur="0.4"/> # <pause dur="0.9"/> our data register direct mode <pause dur="1.0"/> right <pause dur="1.6"/> if <pause dur="1.5"/> the # <pause dur="1.3"/> we want to select <pause dur="1.1"/> a <pause dur="1.3"/> memory address <pause dur="0.3"/> then we've got to add some more information to the operation word because we can't pack <pause dur="0.2"/> the memory address in <pause dur="2.8"/> so here <pause dur="0.6"/> is <pause dur="0.2"/> the operation word <pause dur="0.6"/> as a different op # <pause dur="0.6"/> or the op mode has a different # <pause dur="2.2"/> mode has a has a different value <pause dur="0.9"/> so that we can complete <pause dur="0.2"/> the effective address that we want <pause dur="1.0"/> we'll come back to this topic a little later but <pause dur="0.5"/> essentially <pause dur="0.6"/> what i'm saying is that <pause dur="0.3"/> # <pause dur="1.3"/> you could have <pause dur="1.2"/> a word <pause dur="0.6"/> instruction <pause dur="0.5"/> which is sort of adding two data registers together <pause dur="0.6"/> it would be <pause dur="0.3"/> three words <pause dur="0.2"/> to <pause dur="0.3"/> add <pause dur="0.7"/> # to include a memory address for example in that instruction <pause dur="1.0"/> so there's a variable length of instructions <pause dur="0.7"/> so that's all i want you to get out of 
this is <pause dur="0.4"/> there are variable length instructions <pause dur="5.2"/><kinesic desc="changes transparency" iterated="y" dur="13"/> now <pause dur="8.2"/> as far as the <pause dur="2.0"/> instruction execution just let's look at one instruction <pause dur="0.3"/> we've got <pause dur="1.2"/> an operation word <pause dur="1.2"/> and zero to <pause dur="0.2"/> four extension words <pause dur="0.5"/> depending <pause dur="0.3"/> on what the operation word has in it <pause dur="0.2"/> all right <pause dur="1.5"/> this has to contain all the information <pause dur="0.4"/> that the processor needs <pause dur="0.8"/> if there are more extension words <pause dur="2.7"/> what does the program look like well <pause dur="1.8"/> we'll just think of the simplest one we can <pause dur="0.4"/> think of right <pause dur="0.8"/> it's it's # <pause dur="0.4"/> and that <pause dur="0.9"/> # <pause dur="0.2"/> we could view <pause dur="0.2"/> it as a sequence of instructions <pause dur="1.8"/> and also <pause dur="0.8"/> a data area where all the variables <pause dur="0.4"/> are <pause dur="0.3"/> yeah <pause dur="4.3"/> now <pause dur="1.8"/> the <pause dur="2.9"/> instruction sequence the or the execution sequence <pause dur="0.4"/> will be different <pause dur="0.3"/> to <pause dur="0.2"/> how it's stored in memory <pause dur="2.8"/> now that's reasonable you write for loops don't you <pause dur="0.2"/> yeah </u><u who="su0703" trans="overlap"> mm </u><pause dur="2.1"/> <u who="nm0696" trans="pause"> implicitly <pause dur="0.2"/> you would expect <pause dur="0.6"/> the body of the for loop to be <pause dur="0.6"/> kept being executed <pause dur="0.3"/> so <pause dur="0.7"/> where the <pause dur="0.2"/> sequence of instructions <pause dur="0.7"/> what the body of the for loop is <pause dur="0.4"/> yeah <pause dur="1.3"/> you keep running round those again and again <pause dur="2.9"/> but <pause dur="0.8"/> after you finish the for loop you move on to 
something else <pause dur="0.6"/> so <pause dur="1.8"/> the execution sequence will be different <pause dur="0.2"/> to the stored sequence <pause dur="0.2"/> but let's go back to our stored sequence <pause dur="0.3"/> then <pause dur="0.4"/> we can just say <pause dur="0.3"/> here are some instructions we pack them together one after the other <pause dur="0.5"/> in the memory <pause dur="0.4"/> and here's some <trunc>d</trunc> data variables here <pause dur="4.2"/> the first clue so so that's our model that's all we need to know at <pause dur="0.2"/> at the moment is that <pause dur="0.3"/> there are <pause dur="0.5"/> instructions packed together <pause dur="0.3"/> and there's some data somewhere else <pause dur="3.8"/> the program counter comes into play here <pause dur="1.3"/> right <pause dur="1.2"/> i said a little bit about it last time <pause dur="0.9"/> but <pause dur="0.3"/> it contains <pause dur="2.6"/> the memory address <pause dur="0.2"/> of the next instruction to be executed so if we can <pause dur="0.2"/> freeze the machine <pause dur="0.3"/> this may be where <pause dur="1.7"/> program <pause dur="0.2"/> pointer points to <pause dur="0.2"/> so it's got a memory address that points to there <pause dur="3.4"/> okay <pause dur="7.3"/> any questions so far <pause dur="0.3"/> no <pause dur="0.2"/> not today <pause dur="5.8"/> well <pause dur="2.3"/> one thing that a computer does when you turn it on <pause dur="0.2"/> is to start executing instructions <pause dur="0.8"/> right <pause dur="0.6"/> it will continue doing that till you turn it off <pause dur="2.6"/> mm <pause dur="3.0"/><kinesic desc="changes transparency" iterated="y" dur="3"/> so <pause dur="2.0"/> our processor <pause dur="0.9"/> has <pause dur="0.2"/> an instruction cycle to do this <pause dur="1.6"/> okay and <pause dur="0.4"/> 
what i've done is to say i will take <pause dur="0.3"/> an informal <pause dur="0.3"/> algorithm <pause dur="1.8"/> this is <pause dur="0.3"/> so an approach that i frequently do if i want to encapsulate <pause dur="0.3"/> # <pause dur="0.7"/> # <pause dur="1.3"/> the # something <pause dur="0.2"/> like this <pause dur="0.2"/> then an informal algorithm <pause dur="0.2"/> is a very <pause dur="0.3"/> compact way <pause dur="0.5"/> of an accurate way of describing it <pause dur="0.3"/> to <pause dur="0.4"/> to write all those <trunc>dow</trunc> this down in words would take a considerable <pause dur="0.9"/> you know half a page <pause dur="0.5"/> okay and <pause dur="0.7"/> three or four slides <pause dur="1.2"/> so let's <pause dur="0.8"/> let's look at <pause dur="1.6"/> this this is the <pause dur="0.4"/> execution <pause dur="0.6"/> all right <pause dur="1.4"/> of a single <pause dur="2.1"/> instruction <pause dur="3.0"/> so <pause dur="0.4"/> first of all <pause dur="0.9"/> what do we do <pause dur="0.2"/> we use the <pause dur="0.6"/> the <pause dur="0.2"/> the processor uses the <pause dur="0.4"/> program counter <pause dur="0.2"/> to fetch the operation word all right that's the start of instruction or potentially the start of instruction <pause dur="2.2"/> it would have to increment the program counter by two because <pause dur="0.8"/> if it's going to fetch more things from the <pause dur="0.4"/> # # more parts of the instruction <pause dur="0.3"/> then <pause dur="0.4"/> this would now point to any possible <pause dur="0.2"/> extension words <pause dur="0.3"/> possibly a memory address <pause dur="3.3"/> it would have to <pause dur="1.7"/> split up the operation words into its component <pause dur="1.1"/> fields <pause dur="0.3"/> operation <pause dur="1.5"/> op mode <pause dur="0.8"/> data 
register <pause dur="0.6"/> okay <pause dur="4.4"/> if <pause dur="0.4"/> there's a memory address there <pause dur="1.3"/> okay or or a constant <pause dur="0.8"/> then <pause dur="0.6"/> it would <pause dur="0.7"/> keep fetching the extension words <pause dur="0.8"/> # <pause dur="1.0"/> incrementing the <pause dur="0.2"/> program counter by two every time is does one <pause dur="0.5"/> mm <pause dur="0.4"/> so it's now <pause dur="1.0"/> building up all the information to get <pause dur="0.2"/> the whole instruction so <pause dur="0.3"/> what have we done <pause dur="1.0"/> here <pause dur="0.4"/> this part <pause dur="0.3"/> from here <pause dur="0.4"/> to here <pause dur="1.8"/> all right <pause dur="0.7"/> simply <pause dur="0.4"/> how do we get <pause dur="0.3"/> all of the components <pause dur="0.2"/> of an instruction <pause dur="0.6"/> to execute <pause dur="2.7"/> now <pause dur="5.2"/> having <pause dur="1.9"/> got all the various components we can now <pause dur="1.2"/> get the operands <pause dur="1.0"/> because <pause dur="1.3"/> all the op all the addressing modes in fact have been <pause dur="1.6"/> # <pause dur="0.5"/> encoded it <pause dur="0.9"/> in the operation word <pause dur="1.3"/> we would then use <pause dur="0.3"/> the addressing mode <pause dur="0.2"/> to get the operand <pause dur="0.3"/> whether it means fetching it from a register <pause dur="0.2"/> or fetching it from memory <pause dur="0.3"/> or <pause dur="0.5"/> taking a copy of what the extension words in the in the <pause dur="0.7"/> # <pause dur="2.0"/> to get the immediate <pause dur="0.3"/> # value of the constant <pause dur="0.4"/> okay <pause dur="1.7"/> and it's only at this point we can actually execute it <pause dur="3.3"/> okay so we can now execute the instruction <pause dur="2.1"/> it depends on the instruction but <pause dur="0.7"/> at this point <pause dur="0.2"/> you can update <pause dur="1.4"/> the 
status register <pause dur="0.2"/> the condition codes in <pause dur="0.2"/> the status register <pause dur="2.4"/> all right <pause dur="0.7"/> and we can now <pause dur="0.4"/> keep on doing that <pause dur="1.6"/> for ever <pause dur="1.2"/> or until we switch the machine off <pause dur="2.0"/> now one of the things that that <pause dur="0.5"/> # <pause dur="1.6"/> ironies of of # <pause dur="0.3"/> computing is that most <trunc>com</trunc> most of the computers you're using your own <pause dur="0.2"/> P-C # <pause dur="0.2"/> # <pause dur="0.7"/> is not <pause dur="0.2"/> execute is <pause dur="0.5"/> not doing any real work at all most of the time <pause dur="3.5"/> processors are very fast they do do <pause dur="0.4"/> execute a lot of instructions per second <pause dur="1.8"/> even a million of them <pause dur="0.2"/> or <pause dur="0.3"/> more <pause dur="0.8"/> # <pause dur="0.5"/> the <pause dur="1.5"/> so what does it do while you're waiting to type something in some data for a program <pause dur="0.4"/> just doesn't do anything <pause dur="1.0"/> but has to execute null instructions all the time <pause dur="0.9"/> in order <pause dur="0.5"/> to <pause dur="0.5"/> because <pause dur="1.5"/> has to <pause dur="0.7"/> execute that <pause dur="0.3"/> all the time <pause dur="2.8"/> now <pause dur="0.2"/> how do we cope with that how the the <pause dur="0.2"/> the # <pause dur="0.4"/> what the machine does <pause dur="0.4"/> # <pause dur="0.5"/> to try to share out the <gap reason="inaudible" extent="1 sec"/> all 
users that really isn't the topic here but <pause dur="0.3"/> clearly there is time <pause dur="1.1"/> between any <pause dur="0.3"/> executing any given program <pause dur="0.3"/> to go and execute other peoples' programs <pause dur="0.3"/> and that's not <gap reason="inaudible" extent="1 sec"/> issue that is employed <pause dur="0.7"/> but <pause dur="0.3"/> not for <pause dur="0.4"/> <gap reason="inaudible" extent="1 sec"/><pause dur="0.5"/> so what have we done today <pause dur="1.7"/> we looked at identities with particular instructions <pause dur="1.0"/> # we've introduced three addressing modes <pause dur="1.4"/> and we've seen <pause dur="0.3"/> how <pause dur="0.3"/> the machine itself <pause dur="0.6"/> executes instructions <pause dur="0.2"/> we have refined our model <pause dur="1.0"/> of the process <pause dur="1.7"/> we now have enough <pause dur="0.3"/> to go and write it in the programs but <pause dur="0.9"/> all i have to do is <unclear>to introduce</unclear> <pause dur="0.9"/> a few more <pause dur="0.7"/> # assembler <pause dur="1.4"/> # instructions in order to create that <pause dur="0.9"/> so we'll start on that in a couple of weeks
</u></body>
</text></TEI.2>